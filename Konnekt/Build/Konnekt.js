var Konnekt = (function() {    var CreateKonnektDT = (function() {        function CreateKonnektDT(data, name, parent, scope) {            var _events = {                    "set": [],                    "postset": [],                    "create": [],                    "postcreate": [],                    "delete": [],                    "postdelete": [],                    "splice": [],                    "postsplice": [],                    "push": [],                    "postpush": [],                    "pop": [],                    "postpop": [],                    "shift": [],                    "postshift": [],                    "unshift": [],                    "postunshift": [],                    "fill": [],                    "postfill": [],                    "reverse": [],                    "postreverse": [],                    "sort": [],                    "postsort": [],                    "addlistener": [],                    "postaddlistener": [],                    "removelistener": [],                    "postremovelistener": [],                    "addchildlistener": [],                    "postaddchildlistener": [],                    "removechildlistener": [],                    "postremovechildlistener": []                },                _ignoreList = ['__proto__', '_stopChange'],                _loopEvents = function(events, e) {                    if (!e._stopPropogration && events) {                        for (var x = 0, len = events.length; x !== len; x++) {                            events[x](e);                            if (e._stopPropogration) break;                        }                    }                },                _onevent = function(e) {                    if (e.listener) {                        var _local = e.local[e.listener],                            _child = e.local[(e.listener.replace('__kb', '__kbparent'))];                        /* Local */                        if (isObject.call(_local)) {                            _loopEvents(_local[e.key], e);                            _loopEvents(_local['*'], e);                        } else {                            _loopEvents(_local, e);                        }                        /* Child */                        if (isObject.call(_child)) {                            _loopEvents(_child[e.key], e);                            _loopEvents(_child['*'], e);                        } else {                            _loopEvents(_child, e);                        }                    }                    _loopEvents(e.local.__kbref.__kbevents[e.type], e);                    return e._preventDefault;                },                ArrSort = Array.prototype.sort;            if (!Object.prototype._toString) Object.prototype._toString = Object.prototype.toString;            if (!Object._keys) Object._keys = Object.keys;            Object.prototype.toString = function() {                if (this instanceof Mixed) return "[object Mixed]";                return Object.prototype._toString.apply(this, arguments);            }            Object.keys = function(v, type) {                return Object._keys(v)                    .filter(function(k) {                        return ((!type) || ((type === 'object' || type === 'o')) ? (isNaN(parseInt(k, 10))) : (type === 'all' ? true : (!isNaN(parseInt(k, 10)))));                    });            };            /* The Main constructor */            function Mixed(data, name, parent, scope) {                data = (data === undefined ? {} : data);                /* Object prototype extensions chained down to the function */                ;                var KonnektDT = {};                var prox = (!!window.Proxy ? new Proxy(KonnektDT, {                        set: proxySet,                        deleteProperty: proxyDelete                    }) : KonnektDT),                    keys = Object.keys(data, 'all');                Object.defineProperties(KonnektDT, {                    __kbname: setDescriptor((typeof name === 'string' ? name : "default"), true, true),                    __kbref: setDescriptor((parent ? (parent.__kbref || parent) : prox), true, true),                    __kbscopeString: setDescriptor((scope || ""), true, true),                    __kbImmediateParent: setDescriptor((parent || null), true, true),                    __kbsubscribers: setDescriptor({}),                    __kblisteners: setDescriptor({}),                    __kbupdatelisteners: setDescriptor({}),                    __kbparentlisteners: setDescriptor({}),                    __kbparentupdatelisteners: setDescriptor({}),                    __kbcreatelisteners: setDescriptor([]),                    __kbdeletelisteners: setDescriptor([]),                    __kbparentcreatelisteners: setDescriptor([]),                    __kbparentdeletelisteners: setDescriptor([]),                    __kbmethodlisteners: setDescriptor([]),                    __kbmethodupdatelisteners: setDescriptor([]),                    __kbpointers: setDescriptor({}),                    __kbevents: setDescriptor(_events),                    length: setDescriptor(0, true),                    __kbnonproxy: setDescriptor(KonnektDT, false, true),                    __kbproxy: setDescriptor(prox, false, true),                    _stopChange: setDescriptor(false, true)                });                KonnektDT.__proto__ = Mixed.prototype;                for (var x = 0, len = keys.length; x < len; x++) {                    prox.set(keys[x], data[keys[x]]);                }                /* clear listeners */                KonnektDT.__kbevents.addlistener = [];                KonnektDT.__kbevents.removelistener = [];                KonnektDT.addActionListener('addlistener', function(e) {                        if (typeof e.arguments[0] === 'string' && e.local.__kbpointers[e.arguments[0]] !== undefined) {                            var localPointer = e.local.__kbpointers[e.arguments[0]],                                localLayer = localPointer.point.getLayer(localPointer.keys);                            if (localLayer[e.arguments[0]] !== undefined) localLayer[e.arguments[2]](e.arguments[0], e.arguments[1]);                        }                    })                    .addActionListener('removelistener', function(e) {                        if (typeof e.arguments[0] === 'string' && e.local.__kbpointers[e.arguments[0]] !== undefined) {                            var localPointer = e.local.__kbpointers[e.arguments[0]],                                localLayer = localPointer.point.getLayer(localPointer.keys);                            if (localLayer[e.arguments[0]] !== undefined) localLayer[e.arguments[2]](e.arguments[0], e.arguments[1]);                        }                    })                return prox;            }            /* Helper methods and the main proxy Methods */            function eventObject(obj, key, type, value, oldValue, args, listener, stopChange) {                this.stopPropogation = function() {                    this._stopPropogration = true;                }                this.preventDefault = function() {                    this._preventDefault = true;                }                this.local = obj;                this.key = key;                this.arguments = args;                this.event = type;                this.type = type;                this.listener = listener;                this.name = obj.__kbname;                this.root = obj.__kbref;                this.scope = obj.__kbscopeString;                this.parent = obj.__kbImmediateParent;                this.value = value;                this.oldValue = oldValue;                this.stopChange = stopChange;            }            function setDescriptor(value, writable, redefinable, enumerable) {                return {                    value: value,                    writable: !!writable,                    enumerable: !!enumerable,                    configurable: !!redefinable                }            }            function setCustomDescriptor(func, writable, redefinable) {                return {                    get: function() {                        return func.call(this);                    },                    set: function(v) {                        if (!!writable) func = v;                    },                    enumerable: false,                    configurable: !!redefinable                }            }            function setBindDescriptor(key, value) {                var _value = value,                    _oldValue = value,                    _key = key,                    _set = function(v, e) {                        _oldValue = _value;                        _value = v;                        if (!e.stopChange) {                            e.listener = '__kbupdatelisteners';                            e.type = 'postset';                            _onevent(e);                        }                    };                return {                    get: function() {                        return _value;                    },                    set: function(v) {                        var e = new eventObject(this, _key, 'set', v, _value, arguments, '__kblisteners', this._stopChange);                        if (_onevent(e) !== true) {                            _set(v, e);                            if (!this._stopChange) this.callSubscribers(_key, _value, _oldValue);                        }                        this._stopChange = false;                    },                    configurable: true,                    enumerable: true                }            }            function setPointer() {                var points = Array.prototype.slice.call(arguments),                    obj = points.shift();                return {                    get: function() {                        return points.reduce(function(o, p) {                            return o[p];                        }, obj);                    },                    set: function(v) {                        var local = points.slice(0, (points.length - 1)).reduce(function(o, p) {                            return o[p];                        }, obj);                        (this._stopChange ? local.stopChange() : local)[points[(points.length - 1)]] = v;                        this._stopChange = false;                    },                    enumerable: true,                    configurable: true                }            }            function parseParentListenersToNewObjects(mixed, target) {                var listeners = [{                            listener: '__kbparentlisteners',                            action: 'addChildListener'                        },                        {                            listener: '__kbparentupdatelisteners',                            action: 'addChildUpdateListener'                        },                        {                            listener: '__kbparentcreatelisteners',                            action: 'addChildCreateListener'                        },                        {                            listener: '__kbparentdeletelisteners',                            action: 'addChildDeleteListener'                        }                    ],                    keys = [],                    _currListener;                for (var x = 0, len = listeners.length; x < len; x++) {                    _currListener = mixed[listeners[x].listener];                    if (isObject.call(_currListener)) {                        keys = Object.keys(_currListener);                        for (var i = 0, lenI = keys.length; i < lenI; i++) {                            for (var z = 0, lenZ = _currListener[keys[i]].length; z < lenZ; z++) {                                target[listeners[x].method](keys[i], _currListener[keys[i]][z]);                            }                        }                    } else {                        for (var i = 0, lenI = _currListener.length; i < lenI; i++) {                            target[listeners[x].method](_currListener[i]);                        }                    }                }            }            /* needs looked into if even necessary */            function parsePointerEvents(target, key) {                var events = [{                            listener: '__kblisteners',                            method: 'addDataListener'                        },                        {                            listener: '__kbupdatelisteners',                            method: 'addDataUpdateListener'                        }                    ],                    keys = [],                    _currListener;                if (target[key].__kbImmediateParent) {                    for (var x = 0, len = events.length; x < len; x++) {                        _currListener = target[events[x].listener];                        keys = Object.keys(_currListener);                        for (var i = 0, lenI = keys.length; i < lenI; i++) {                            if (key === keys[x]) {                                for (var z = 0, lenZ = _currListener[keys[x]].length; z < lenZ; z++) {                                    if (target[key].__kbImmediateParent[events[x].listener][key] === undefined) target[key].__kbImmediateParent[events[x].listener][key] = [];                                    target[key].__kbImmediateParent[events[x].listener][key].push(_currListener[keys[x]][z]);                                }                            }                        }                    }                }                parseParentListenersToNewObjects(target, target[key]);            }            /* create check if value is just undefined but descriptor is set */            function proxySet(target, key, value) {                if (!isObservable(target, key) && key !== 'length') {                    target.set(key, value);                } else {                    if (key === 'length') {                        if (value > target.length && target[(value - 1)] !== undefined) {                            target.length = value;                        } else if (value < target.length) {                            for (var x = value, len = (target.length); x < len; x++) {                                if (target[x]) delete target[x];                            }                            target.length = value;                        }                    } else {                        target[key] = value;                    }                    return true;                }            }            /* Need to handle removing parentListeners prior to removal */            function proxyDelete(target, key) {                target.del(key);                return true;            }            function handleNewProperty(target, key, value) {                var _layer = this.__kbnonproxy,                    _isMixed = isMixed(value),                    _isObject = isObject(value),                    _isArray = isArray(value);                if (_isMixed && value.__kbname !== target.__kbname) {                    if (value.__kbname === 'default') {                        target.merge(value, key);                    } else if (!target.__kbpointers[key]) {                        target.addPointer(value, key);                    }                } else {                    var e = new eventObject(this, key, 'create', value, undefined, [], '__kbcreatelisteners', this._stopChange),                        onEvent = _onevent(e),                        keyNum = parseInt(key, 10);                    if (onEvent !== true) {                        if ((_isObject || _isArray) && Object.keys(value, 'all').length !== 0) {                            handleNewProperty.call(this, target, key, {});                            for (var x = 0, keys = Object.keys(value, 'all'), len = keys.length; x < len; x++) {                                handleNewProperty.call(this[key], target[key], keys[x], value[keys[x]]);                            }                        } else {                            if (_isObject || _isArray) {                                value = new Mixed(value, target.__kbname, target, target.__kbscopeString + (target.__kbscopeString.length !== 0 ? "." : "") + key);                                parseParentListenersToNewObjects(target, value);                            }                            Object.defineProperty(target, key, setBindDescriptor(key, value));                            if (!isNaN(keyNum) && target.length <= keyNum) target.length = (keyNum + 1);                            e.listener = '__kbupdatelisteners';                            e.type = 'postcreate';                            _onevent(e);                        }                    }                }            }            /* replaces the use of using a proxy to run the parser through */            function recSet(obj, key, value, stopChange) {                var _isMixed = isMixed(value),                    _isObject = isObject(value),                    _isArray = isArray(value);                if (_isMixed && value.__kbname !== obj.__kbname) {                    if (value.__kbname === 'default') {                        obj.merge(value, key);                    } else if (!obj.__kbpointers[key]) {                        obj.addPointer(value, key);                    }                } else if (obj[key] === undefined) {                    if (_ignoreList.indexOf(key) === -1) {                        handleNewProperty.call(this, obj, key, value);                    } else {                        (!!stopChange ? obj.stopChange() : obj)[key] = value;                    }                } else {                    if (_isObject || _isArray) {                        for (var x = 0, keys = Object.keys(value, 'all'), len = keys.length; x < len; x++) {                            recSet.call(this[key], obj[key], keys[x], value[keys[x]], stopChange);                        }                    } else {                        (!!stopChange ? obj.stopChange() : obj)[key] = value;                    }                }            }            function ignoreCreate(name) {                if (_ignoreList.indexOf(name) === -1) _ignoreList.push(name);                return this;            }            /* REGION Object extensions */            function type(v) {                return ({}).toString.call(v).match(/\s([a-zA-Z]+)/)[1].toLowerCase();            }            function sizeof(v) {                var cache = [];                function recGet(obj) {                    var keys = Object.keys(obj, 'all'),                        count = 0,                        _curr = undefined;                    for (var x = 0, len = keys.length; x < len; x++) {                        _curr = obj[keys[x]];                        if (typeof _curr === 'object' && _curr !== undefined && _curr !== null) {                            if (cache.indexOf(_curr) === -1) {                                cache.push(_curr);                                count += recGet(_curr);                            }                        } else if (typeof _curr === 'string') {                            count += (_curr.length * 2);                        } else if (typeof _curr === 'number') {                            count += 8;                        } else if (typeof _curr === 'boolean') {                            count += 4;                        } else if (typeof _curr === 'function') {                            count += (_curr.toString().length * 2);                        }                        count += (keys[x].length * 2);                    }                    return count;                }                return recGet((v || this)) + " Bytes (Rough estimate)";            }            function isObject(v) {                return (type((v !== undefined ? v : this)) === 'object');            }            function isArray(v) {                return (type((v !== undefined ? v : this)) === 'array');            }            function isMixed(v) {                return (type((v !== undefined ? v : this)) === 'mixed');            }            function isObservable(obj, prop) {                prop = (typeof obj === 'string' ? obj : prop);                obj = (typeof obj === 'string' ? this : obj);                var desc = Object.getOwnPropertyDescriptor(obj, prop);                return (desc ? (desc.value === undefined) : false);            }            function stringify(v) {                var cache = [];                return JSON.stringify((v || this), function(key, value) {                    if (isArray(value) || isObject(value)) {                        if (cache.indexOf(value) !== -1) {                            return;                        }                        cache.push(value);                    }                    return value;                });            }            function getKeys(v, type) {                type = (typeof v === 'string' ? v : (!type ? 'object' : type));                v = (typeof v === 'string' || v === undefined ? this : v);                return Object.keys(v, type);            }            function getIndexes(v) {                v = (v !== undefined ? (typeof v === 'object' ? v : this[v]) : this);                var _ret = [];                for (var x = 0, len = v.length; x < len; x++) {                    if (v[x] !== undefined) _ret[_ret.length] = x;                }                return _ret            }            function keyCount() {                return this.getKeys('object').length;            }            function indexCount() {                return (this).length;            }            function count() {                return (this.keyCount + this.indexCount);            }            /* ENDREGION Object extensions */            /* REGION Object methods */            function add(key, value) {                set.call(this, key, value);                return this;            }            function set(key, value) {                if (typeof key === 'number') key = key.toString();                var _layer = (key.indexOf('.') !== -1 ? this.__kbnonproxy.setLayer(key) : this.__kbnonproxy);                if (key.indexOf('.') !== -1) key = key.split('.').pop();                var e = new eventObject(this, key, 'set', value, (this[key]), arguments, '__kbmethodlisteners'),                    onEvent = _onevent(e);                if (onEvent !== true) {                    recSet.call(this, _layer, key, value, this._stopChange);                    this.stopChange = undefined;                    e.type = 'postset';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this;            }            /* Always return Proxy if used `.get` and `.getlayer` both apply this rule */            function get(key) {                if (typeof key === 'number') key = key.toString();                var _layer = (key.indexOf('.') !== -1 ? this.getLayer(key) : this);                if (key.indexOf('.') !== -1) key = key.split('.').pop();                if (_layer) {                    return _layer[key];                } else {                    console.warn('Module: KonnektDT, Method: get, nothing exists on %o with the key %o', this, key);                }            }            function exists(key) {                var _layer = (key.indexOf('.') !== -1 ? this.__kbnonproxy.getLayer(key) : this.__kbnonproxy);                if (key.indexOf('.') !== -1) key = key.split('.').pop();                if (!_layer) return !!_layer;                return (_layer[key] !== undefined);            }            function addPrototype(key, value) {                var _layer = (key.indexOf('.') !== -1 ? this.__kbnonproxy.setLayer(key) : this.__kbnonproxy);                if (key.indexOf('.') !== -1) key = key.split('.').pop();                if (_layer[key] === undefined) {                    Object.defineProperty(_layer.__proto__, key, setDescriptor(value, true, true));                } else {                    console.error('Your attempting to add your prototype with the prop %O that already exists on %O', prop, _layer);                }                return this;            }            /* Handle listener sharing (done in addlistener Methods) */            function addPointer() {                var points = Array.prototype.slice.call(arguments),                    passobj = points.shift(),                    prop = points[(points.length - 1)];                if (!(passobj instanceof Mixed)) passobj = new Mixed(passobj, passobj.__kbname);                var e = new eventObject(this, prop, 'create', passobj[prop], undefined, [], '__kbcreatelisteners', this._stopChange),                    _layer = this.__kbnonproxy;                e.root = passobj.__kbref.__kbproxy;                if (_onevent(e) !== true) {                    Object.defineProperty(_layer, prop, setPointer.apply(_layer, arguments));                    _layer.__kbpointers[prop] = {                        keys: points.join('.'),                        point: passobj                    };                    parsePointerEvents(_layer, prop);                    e.listener = '__kbupdatelisteners';                    e.type = 'postcreate';                    _onevent(e);                }                return this;            }            /* handles all deleting */            function del(key, bypass) {                var _isNumber = (typeof key === 'number' || !isNaN(parseInt(key, 10)));                if (_isNumber) key = key.toString();                var _layer = (key.indexOf('.') !== -1 ? this.getLayer(key) : this),                    _localProp = key.split('.').pop();                if (!!_layer && _layer[_localProp] !== undefined) {                    if (_isNumber && _layer.length > parseInt(key, 10) && !bypass) {                        _layer = _layer.__kbnonproxy;                        _layer.splice(_localProp, 1);                    } else {                        var e = new eventObject(_layer, key, 'delete', _layer[_localProp], undefined, [], '__kbdeletelisteners', this._stopChange),                            onEvent = _onevent(e);                        if (onEvent !== true) {                            _layer = _layer.__kbnonproxy;                            Object.defineProperty(_layer, _localProp, setDescriptor(undefined, true, true, false));                            delete _layer[_localProp];                            if (_isNumber && _layer.length > parseInt(key, 10) && bypass) _layer.length = (_layer.length - 1);                            e.listener = '__kbupdatelisteners';                            e.type = 'postdelete';                            e.oldValue = e.value;                            e.value = undefined;                            _onevent(e);                        }                    }                }                return this;            }            function move(obj, prop) {                this.__kbnonproxy.set(prop, obj[prop]);                if (!isMixed(obj)) {                    obj[prop] = null;                    delete obj[prop];                } else {                    obj.del(prop);                }                return this;            }            function copy(obj, key) {                var _layer = this.__kbnonproxy;                if (!isMixed(obj)) {                    _layer.set(key, obj[key]);                } else {                    if (obj.__kbname === 'default') {                        _layer.merge(obj[key], key);                    } else {                        _layer.addPointer(obj, key);                    }                }                return this;            }            function merge(obj, key) {                var cache = [],                    _layer = this.__kbnonproxy;                function recMerge(from, to) {                    var keys = (isMixed(from) ? from.keys('object') : Object.keys(from)),                        _curr;                    for (var x = 0, len = keys.length; x < len; x++) {                        _curr = from[keys[x]];                        if (typeof _curr === 'object' && cache.indexOf(_curr) === -1 && to[keys[x]] !== 'undefined') {                            recMerge(_curr, to);                        } else {                            to.set(keys[x], (typeof _curr === 'object' ? {} : _curr));                        }                    }                }                if (key && _layer[key] === undefined) _layer.set(key, {});                recMerge(obj, (key ? _layer[key] : _layer));                return this;            }            /* ENDREGION Object methods */            /* REGION Array methods */            function copyWithin(target, start, end) {                start = (start || 0);                end = (end || 0);                var e = new eventObject(this, target, 'copyWithin', this[target], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true && target < _layer.length) {                    target = (target < 0 ? (_layer.length - 1) : target);                    start = (start < _layer.length ? start : (_layer.length - 1));                    end = (end < _layer.length ? end : (_layer.length - 1));                    start = (start < 0 ? (_layer.length - 1) : start);                    end = (start < 0 ? (_layer.length - 1) : end);                    for (var x = start; x <= end; x++) {                        _layer.set((target + (x - start)), _layer[x]);                    }                    e.type = 'postcopyWithin';                    e.listener = '__kbmethodupdatelisteners'                    _onevent(e);                }                return this;            }            function fill(value, start, end) {                start = (start !== undefined ? Math.max(0, start) : 0);                end = ((end !== undefined && end <= this.length) ? Math.min(this.length, Math.max(0, end)) : this.length);                var e = new eventObject(this, _start, 'fill', this[_start], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    for (var x = a.key; x < end; x++) {                        _layer[x] = value;                    }                    e.type = 'postfill';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this;            }            function pop() {                var e = new eventObject(this, (this.length - 1), 'pop', this[(this.length - 1)], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    var _ret = _layer[(_layer.length - 1)];                    _layer.del((this.length - 1));                    e.type = 'postpop';                    e.listener = '__kbmethodupdatelisteners'                    _onevent(e);                    return _ret;                }                return null;            }            function push(v) {                var e = new eventObject(this, (this.length), 'push', v, undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    _layer.set(_layer.length, v);                    e.type = 'postpush';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this.length;            }            function reverse() {                var e = new eventObject(this, undefined, 'reverse', undefined, undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    var left = null,                        right = null,                        length = _layer.length;                    for (left = 0; left < length / 2; left += 1) {                        right = length - 1 - left;                        var temporary = _layer[left];                        _layer[left] = _layer[right];                        _layer[right] = temporary;                        temporary = null;                    }                    e.type = 'postreverse';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this;            }            function shift() {                var e = new eventObject(this, 0, 'shift', this[0], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    var _ret = _layer[a.key];                    for (var x = a.key, len = (this.length - 1); x < len; x++) {                        _layer[x] = _layer[(x + 1)];                    }                    _layer.del((this.length - 1));                    e.type = 'postshift';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return null;            }            function sort() {                var e = new eventObject(this, undefined, 'sort', undefined, undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    ArrSort.apply(_layer, arguments);                    e.type = 'postsort';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this;            }            function splice(index, remove, insert) {                index = (typeof index === 'string' ? parseInt(index, 10) : index);                var e = new eventObject(this, index, 'splice', undefined, undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy,                    _hasProxy = !!window.Proxy;                if (_onevent(e) !== true) {                    var _ret = [],                        _inserts = Array.prototype.slice.call(arguments, 2),                        _insertLen = (_inserts.length - 2),                        _index = 0;                    if (remove !== 0 && _layer[((index - 1) + remove)] !== undefined) {                        for (var x = 0, len = remove; x < len; x++) {                            _ret.push(_layer[index + x]);                            for (var i = (index + x), lenI = (this.length - 1); i < lenI; i++) {                                _layer[i] = _layer[(i + 1)];                            }                            _layer.del((_layer.length - 1), true)                        }                    }                    if (_insertLen !== 0) {                        for (var x = 0, len = _insertLen; x < len; x++) {                            _index = (index + (Math.min(1, x)));                            for (var i = _layer.length, lenI = _index; i > lenI; i--) {                                _layer.set(i, _layer[(i - 1)]);                            }                            _layer.set(_index, _inserts[x]);                        }                    }                    e.type = 'postsplice';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                    return _ret;                } else {                    return [];                }            }            function unshift() {                var e = new eventObject(this, 0, 'unshift', this[0], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    var args = Array.prototype.slice.call(arguments);                    for (var x = ((_layer.length - 1) + args.length), len = args.length; x !== -1; x--) {                        if (x < len) {                            _layer.set(x, args[x]);                        } else {                            _layer.set(x, _layer[(x - args.length)]);                        }                    }                    e.type = 'postunshift';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this.length;            }            /* ENDREGION Array methods */            /* REGION Event Listeners */            function stopChange() {                this.__kbnonproxy._stopChange = true;                return this;            }            function splitScopeString(scopeString) {                return scopeString.split('.');            }            function setLayer(scopeString) {                var scope = splitScopeString(scopeString);                function rec(scope) {                    var key = scope[0];                    if (this[key] === undefined && (scope.length - 1) !== 0) this[key] = Mixed({}, this.__kbname, this, this.__kbscopeString + "." + key);                    if (!isMixed(this[key])) return this;                    if ((scope.length - 1) !== 0) {                        scope.shift();                        return rec.call(this[key], scope);                    }                    return this[key];                }                return rec.call(this, scope);            }            function getLayer(scopeString) {                var scope = splitScopeString(scopeString);                function rec(scope) {                    var key = scope[0];                    if (this[key] === undefined && (scope.length - 1) !== 0) return null;                    if (!isMixed(this[key])) return this;                    if ((scope.length - 1) !== 0) {                        scope.shift();                        return rec.call(this[key], scope);                    }                    return this[key];                }                return rec.call(this, scope);            }            function addListener(type, listener) {                return function(prop, func) {                    arguments = Array.prototype.slice.call(arguments);                    arguments.push(type);                    var _listeners = this[listener],                        e = new eventObject(this, listener, 'addlistener', _listeners, undefined, arguments, ''),                        _layer = this.__kbnonproxy;                    if (typeof prop === 'string' && splitScopeString(prop).length !== 1) {                        var scopeString = splitScopeString(prop);                        prop = scopeString.pop();                        scopeString = scopeString.join(".");                        e.local = this.getLayer(scopeString);                        _listeners = e.local[listener];                        e.value = _listeners;                    }                    if (_onevent(e) !== true) {                        if (isObject.call(_listeners)) {                            if (_listeners[prop] === undefined) _listeners[prop] = [];                            _listeners[prop].push(func);                            e.type = 'postaddlistener'                            _onevent(e);                        } else if (isArray.call(_listeners)) {                            if (typeof prop === 'function') {                                _listeners.push(prop);                                e.type = 'postaddlistener'                                _onevent(e);                            }                        }                    }                    return this;                }            }            function removeListener(type, listener) {                return function(prop, func) {                    arguments = Array.prototype.slice.call(arguments);                    arguments.push(type);                    var _listeners = this[listener],                        e = new eventObject(this, listener, 'removelistener', _listeners, undefined, arguments, ''),                        _layer = this.__kbnonproxy;                    if (typeof prop === 'string' && splitScopeString(prop).length !== 1) {                        var scopeString = splitScopeString(prop);                        scopeString.pop();                        scopeString.join(".");                        e.local = this.getLayer(scopeString);                        _listeners = e.local[listener];                        e.value = _listeners;                        prop = splitScopeString(prop).pop();                    }                    if (_onevent(e) !== true) {                        if (isObject.call(_listeners)) {                            if (_listeners[prop] !== undefined) {                                for (var x = 0, len = _listeners[prop].length; x < len; x++) {                                    if (_listeners[prop][x].toString() === func.toString()) {                                        _listeners[prop].splice(x, 1);                                        e.type = 'postremovelistener';                                        _onevent(e);                                        break;                                    }                                }                            }                        } else if (isArray.call(_listeners)) {                            if (typeof prop === 'function') {                                for (var x = 0, len = _listeners.length; x < len; x++) {                                    if (_listeners[x].toString() === prop.toString()) {                                        _listeners.splice(x, 1);                                        e.type = 'postremovelistener';                                        _onevent(e);                                        break;                                    }                                }                            }                        }                    }                    return this;                }            }            function addActionListener(type, func) {                var _layer = this.__kbnonproxy;                if (_layer.__kbref.__kbevents[type] !== undefined) {                    _layer.__kbref.__kbevents[type].push(func);                }                return this;            }            function removeActionListener(type, func) {                var _layer = this.__kbnonproxy;                if (_layer.__kbref.__kbevents[type] !== undefined) {                    for (var x = 0, len = _layer.__kbref.__kbevents[type]; x < len; x++) {                        if (_layer.__kbref.__kbevents[type][x].toString() === func.toString()) {                            _layer.__kbref.__kbevents[type].splice(x, 1);                            break;                        }                    }                }                return this;            }            function addChildListener(type, listener) {                function recAddListener(prop, func, listener) {                    var children = Object.keys(this, 'all').filter((function(p) {                        return (isMixed.call(this[p]));                    }).bind(this));                    var _local = this,                        _locProp = prop;                    if (typeof prop === 'string' && splitScopeString(prop).length !== 1) {                        var scopeString = splitScopeString(prop);                        _locProp = scopeString.pop();                        scopeString = scopeString.join(".");                        _local = this.getLayer(scopeString);                        if (_local[listener][_locProp] === undefined) _local[listener][_locProp] = [];                        _local[listener][_locProp].push(func);                    }                    if (isObject.call(_local[listener])) {                        if (_local[listener][_locProp] === undefined) _local[listener][_locProp] = [];                        _local[listener][_locProp].push(func);                        var localPointer = _local.__kbpointers[_locProp],                            localLayer = localPointer.point.getLayer(localPointer.keys);                        if (localLayer[_locProp] !== undefined) {                            if (localLayer[listener][_locProp] === undefined) localLayer[listener][_locProp] = [];                            localLayer[listener][_locProp].push(_func);                        }                    } else {                        _local[listener].push(func);                    }                    for (var x = 0, len = children.length; x < len; x++) {                        recAddListener.call(this[children[x]], prop, func, listener);                    }                }                return function(prop, func) {                    arguments = Array.prototype.slice.call(arguments);                    arguments.push(type);                    var e = new eventObject(this, listener, 'addchildlistener', undefined, undefined, arguments, '');                    if (_onevent(e) !== true) {                        recAddListener.call(this.__kbnonproxy, prop, func, listener);                        e.type = 'postaddchildlistener';                        _onevent(e);                    }                    return this;                }            }            function removeChildListener(type, listener) {                function recRemoveListener(prop, func, listener) {                    var children = Object.keys(this, 'all').filter((function(p) {                        return (isMixed.call(this[p]));                    }).bind(this));                    var _local = this,                        _locProp = prop;                    if (typeof prop === 'string' && splitScopeString(prop).length !== 1) {                        var scopeString = splitScopeString(prop);                        _locProp = scopeString.pop();                        scopeString.join(".");                        _local = this.getLayer(scopeString);                        if (_local[listener][prop] !== undefined) {                            for (var x = 0, len = _local[listener][prop].length; x < len; x++) {                                if (_local[listener][prop][x].toString() === func.toString()) {                                    _local[listener][prop].splice(x, 1);                                    break;                                }                            }                        }                    }                    if (isObject.call(_local[listener])) {                        if (_local[listener][_locProp] !== undefined) {                            for (var x = 0, len = _local[listener][_locProp].length; x < len; x++) {                                if (_local[listener][_locProp][x].toString() === func.toString()) {                                    _local[listener][_locProp].splice(x, 1);                                    break;                                }                            }                            if (_local.__kbpointers.indexOf(_locProp) !== -1) {                                var localPointer = _local.__kbpointers[_locProp],                                    localLayer = localPointer.point.getLayer(localPointer.keys);                                if (localLayer[listener][_locProp] !== undefined) {                                    for (var x = 0, len = localLayer[listener][_locProp].length; x < len; x++) {                                        if (localLayer[listener][_locProp][x].toString() === func.toString()) {                                            localLayer[listener][_locProp].splice(x, 1);                                            break;                                        }                                    }                                }                            }                        }                    } else {                        for (var x = 0, len = _local[listener].length; x < len; x++) {                            if (_local[listener][x].toString() === func.toString()) {                                _local[listener].splice(x, 1);                                break;                            }                        }                    }                    for (var x = 0, len = children.length; x < len; x++) {                        recRemoveListener.call(this[children[x]], prop, func, listener);                    }                }                return function(prop, func) {                    arguments = Array.prototype.slice.call(arguments);                    arguments.push(type);                    var e = new eventObject(this, listener, 'removechildlistener', undefined, undefined, arguments, '');                    if (_onevent(e) !== true) {                        recRemoveListener.call(this.__kbnonproxy, prop, func, listener);                        e.type = 'postremovechildlistener';                        _onevent(e);                    }                    return this;                }            }            function subscribe(prop, func) {                var _layer = this.__kbnonproxy;                if (_layer.__kbsubscribers[prop] === undefined) _layer.__kbsubscribers[prop] = [];                _layer.__kbsubscribers[prop].push(func);                return this;            }            function unsubscribe(prop, func) {                var _layer = this.__kbnonproxy;                if (_layer.__kbsubscribers[prop] !== undefined) {                    for (var x = 0, len = _layer.__kbsubscribers[prop].length; x < len; x++) {                        if (_layer.__kbsubscribers[prop][x].toString() === func.toString()) {                            _layer.__kbsubscribers[prop].splice(x, 1);                            break;                        }                    }                }                return this;            }            function callSubscribers(prop, value, oldValue) {                var _layer = this.__kbnonproxy;                if (_layer.__kbsubscribers[prop] !== undefined) {                    for (var x = 0, len = _layer.__kbsubscribers[prop].length; x < len; x++) {                        _layer.__kbsubscribers[prop].call(this, prop, value, oldValue);                    }                }                return this;            }            /* ENDREGION Event Listeners */            Object.defineProperties(Mixed.prototype, {                /* Helper methods */                typeof: setDescriptor(type, false, true),                sizeof: setDescriptor(sizeof, false, true),                isObject: setDescriptor(isObject, false, true),                isArray: setDescriptor(isArray, false, true),                isMixed: setDescriptor(isMixed, false, true),                isObservable: setDescriptor(isObservable, false, true),                stringify: setDescriptor(stringify, false, true),                getKeys: setDescriptor(getKeys, false, true),                getIndexes: setDescriptor(getIndexes, false, true),                keyCount: setCustomDescriptor(keyCount, false, true),                indexCount: setCustomDescriptor(indexCount, false, true),                count: setCustomDescriptor(count, false, true),                /* Non destructive Array methods */                concat: setDescriptor(Array.prototype.concat),                every: setDescriptor(Array.prototype.every),                filter: setDescriptor(Array.prototype.filter),                find: setDescriptor(Array.prototype.find),                findIndex: setDescriptor(Array.prototype.findIndex),                forEach: setDescriptor(Array.prototype.forEach),                includes: setDescriptor(Array.prototype.includes),                indexOf: setDescriptor(Array.prototype.indexOf),                join: setDescriptor(Array.prototype.join),                lastIndexOf: setDescriptor(Array.prototype.lastIndexOf),                map: setDescriptor(Array.prototype.map),                reduce: setDescriptor(Array.prototype.reduce),                reduceRight: setDescriptor(Array.prototype.reduceRight),                slice: setDescriptor(Array.prototype.slice),                some: setDescriptor(Array.prototype.some),                entries: setDescriptor(Array.prototype.entries),                toLocaleString: setDescriptor(Array.prototype.toLocaleString),                /* Object Methods */                add: setDescriptor(add),                set: setDescriptor(set),                get: setDescriptor(get),                del: setDescriptor(del),                exists: setDescriptor(exists),                addPrototype: setDescriptor(addPrototype),                addPointer: setDescriptor(addPointer),                move: setDescriptor(move),                copy: setDescriptor(copy),                merge: setDescriptor(merge),                /* Array Methods */                copyWithin: setDescriptor(copyWithin),                fill: setDescriptor(fill),                pop: setDescriptor(pop),                push: setDescriptor(push),                reverse: setDescriptor(reverse),                shift: setDescriptor(shift),                sort: setDescriptor(sort),                splice: setDescriptor(splice),                unshift: setDescriptor(unshift),                /* Helpers */                getLayer: setDescriptor(getLayer),                setLayer: setDescriptor(setLayer),                ignoreCreate: setDescriptor(ignoreCreate),                /* Event Listeners */                addActionListener: setDescriptor(addActionListener),                removeActionListener: setDescriptor(removeActionListener),                subscribe: setDescriptor(subscribe),                unsubscribe: setDescriptor(unsubscribe),                callSubscribers: setDescriptor(callSubscribers),                stopChange: setDescriptor(stopChange)            });            Object.defineProperties(Mixed.prototype, {                /* Standard Data Listeners as a single layer */                addDataListener: setDescriptor(addListener('addDataListener', '__kblisteners')),                removeDataListener: setDescriptor(removeListener('removeDataListener', '__kblisteners')),                addDataUpdateListener: setDescriptor(addListener('addDataUpdateListener', '__kbupdatelisteners')),                removeDataUpdateListener: setDescriptor(removeListener('removeDataUpdateListener', '__kbupdatelisteners')),                addDataCreateListener: setDescriptor(addListener('addDataCreateListener', '__kbcreatelisteners')),                removeDataCreateListener: setDescriptor(removeListener('removeDataCreateListener', '__kbcreatelisteners')),                addDataDeleteListener: setDescriptor(addListener('addDataDeleteListener', '__kbdeletelisteners')),                removeDataDeleteListener: setDescriptor(removeListener('removeDataDeleteListener', '__kbdeletelisteners')),                addDataMethodListener: setDescriptor(addListener('addDataMethodListener', '__kbmethodlisteners')),                removeDataMethodListener: setDescriptor(removeListener('removeDataMethodListener', '__kbmethodlisteners')),                addDataMethodUpdateListener: setDescriptor(addListener('addDataMethodUpdateListener', '__kbmethodupdatelisteners')),                removeDataMethodUpdateListener: setDescriptor(removeListener('removeDataMethodUpdateListener', '__kbmethodupdatelisteners')),                /* MultiLayer Child Listeners */                addChildDataListener: setDescriptor(addChildListener('addChildDataListener', '__kbparentlisteners')),                removeChildDataListener: setDescriptor(removeChildListener('removeChildDataListener', '__kbparentlisteners')),                addChildDataUpdateListener: setDescriptor(addChildListener('addChildDataUpdateListener', '__kbparentupdatelisteners')),                removeChildDataUpdateListener: setDescriptor(removeChildListener('removeChildDataUpdateListener', '__kbparentupdatelisteners')),                addChildDataCreateListener: setDescriptor(addChildListener('addChildDataCreateListener', '__kbparentcreatelisteners')),                removeChildDataCreateListener: setDescriptor(removeChildListener('removeChildDataCreateListener', '__kbparentcreatelisteners')),                addChildDataDeleteListener: setDescriptor(addChildListener('addChildDataDeleteListener', '__kbparentdeletelisteners')),                removeChildDataDeleteListener: setDescriptor(removeChildListener('removeChildDataDeleteListener', '__kbparentdeletelisteners')),            });            return Mixed;        }        return CreateKonnektDT;    }());    var CreateKonnektL = (function() {        function CreateKonnektL() {            var _onload = function() {},                _reNodes = /(<\/.*?>)/g;            if (!window.K_Components) window.K_Components = {};            /* main takes name and loads file, after load it checks html and cms html if applicable */            function KonnektL(name) {                function onLoad(method) {                    var unknowns = KonnektL.getUnknowns(method.prototype.k_html);                    if (method.k_cms) {                        unknowns.concat(KonnektL.getUnknowns(method.k_cms.prototype.kcms_html));                    }                    if (unknowns.length !== 0) KonnektL(unknowns);                }                if (typeof name === 'object') {                    for (var x = 0, len = name.length; x < len; x++) {                        if (!K_Components[name[x]]) {                            KonnektL.load(name[x], 'component/' + name[x] + '/' + location.search, _onload);                        } else {                            _onload(name[x], K_Components[name[x]], document.getElementById('script_' + name[x]));                        }                    }                } else if (typeof name === 'string') {                    if (!K_Components[name[x]]) {                        KonnektL.load(name, 'component/' + name + '/' + location.search, _onload);                    } else {                        _onload(name, K_Components[name], document.getElementById('script_' + name));                    }                }            }            /* checks for unregistered components in the html */            KonnektL.getUnknowns = function(html) {                var matched = html.match(_reNodes);                return matched.map(function(k) {                        return k.replace(/[<\/>]/g, "");                    })                    .filter(function(k, i) {                        return ((document.createElement(k) instanceof HTMLUnknownElement) && (matched.indexOf(k, (i + 1)) === -1) && !K_Components[k]);                    });            }            /* loads script tag into html */            KonnektL.load = function(name, url, cb) {                function createNode(name, src, fn) {                    var node = document.createElement('script');                    node.type = 'text/javascript';                    node.charset = 'utf-8';                    node.async = true;                    node.src = src;                    node.id = 'script_' + name;                    node.onload = function() {                        fn(name, K_Components[name], this);                    };                    return node;                }                document.head.appendChild(createNode(name, url, cb));                return KonnektL;            }            KonnektL.onLoad = function(v) {                if (v === undefined) return _onload;                _onload = (typeof v === 'function' ? v : _onload);                return KonnektL;            }            return KonnektL;        }        return CreateKonnektL;    }())    var CreateKB = (function() {        function CreateKB() {            /* This holds global attribute listeners when tied to kb */            var _attrListeners = {},                /* This holds global attribute update listeners when tied to kb */                _attrUpdateListeners = {},                /* This holds global style listeners when tied to kb */                _styleListeners = {},                /* This holds global style update listeners when tied to kb */                _styleUpdateListeners = {},                /* This holds all injected objects, so You can see what is injected */                _injected = {},                /* The symbol to dignify what the master global listener is */                _all = '*',                _texts = ['textContent', 'innerHTML', 'innerText', 'outerHTML', 'outerText', 'appendChild', 'removeChild', 'replaceChild', 'insertAdjacentHTML', 'insertBefore'],                /* A master list of all style prop names */                _allStyles = Object.getOwnPropertyNames(document.documentElement.style),                _allEvents = Object.keys(HTMLElement.prototype).filter(function(v) {                    return (v.indexOf('on') === 0);                }).concat(['addEventListener', 'removeEventListener']),                /* global iterators */                x,                i,                /* Default set method for all listeners, loops through and runs all attached listeners */                _set = function(el, prop, val, ret, args, stopChange) {                    var e = new _changeEvent(el, prop, val, ret, args, undefined, 'set', stopChange);                    if (el.__kb !== undefined) {                        var localAttrListeners = el.__kb._attrListeners,                            localStyleListeners = el.__kb._styleListeners,                            localParentAttrListeners = el.__kb._parentAttrListeners,                            localParentStyleListeners = el.__kb._parentStyleListeners;                        if (localAttrListeners[prop] !== undefined) {                            loopListener(localAttrListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localStyleListeners[prop] !== undefined) {                            loopListener(localStyleListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localAttrListeners[_all] !== undefined) {                            loopListener(localAttrListeners[_all], e);                            if (e._stopPropogation === undefined) {                                loopListener(localStyleListeners[_all], e);                            }                        }                        if (e._stopPropogation === undefined && localParentAttrListeners[prop] !== undefined) {                            loopParentListener(localParentAttrListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localParentStyleListeners[prop] !== undefined) {                            loopParentListener(localParentStyleListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localParentAttrListeners[_all] !== undefined) {                            loopParentListener(localParentAttrListeners[_all], e);                            if (e._stopPropogation === undefined) {                                loopParentListener(localParentStyleListeners[_all], e);                            }                        }                    }                    if (e._stopPropogation === undefined && _attrListeners[prop] !== undefined) {                        loopListener(_attrListeners[prop], e);                    }                    if (e._stopPropogation === undefined && _styleListeners[prop] !== undefined) {                        loopListener(_styleListeners[prop], e);                    }                    if (e._stopPropogation === undefined && _attrListeners[_all] !== undefined) {                        loopListener(_attrListeners[_all], e);                        if (e._stopPropogation === undefined) {                            loopListener(_styleListeners[_all], e);                        }                    }                    if (e._preventDefault !== undefined) return false;                    return true;                },                /* Default update method for all listeners, loops through and runs all attached update listeners */                _update = function(el, prop, val, ret, args, action) {                    var e = new _changeEvent(el, prop, val, ret, args, action, 'update');                    if (el.__kb !== undefined) {                        var localAttrListeners = el.__kb._attrUpdateListeners,                            localStyleListeners = el.__kb._styleUpdateListeners,                            localParentAttrListeners = el.__kb._parentAttrUpdateListeners,                            localParentStyleListeners = el.__kb._parentStyleUpdateListeners;                        if (localAttrListeners[prop] !== undefined) {                            loopListener(localAttrListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localStyleListeners[prop] !== undefined) {                            loopListener(localStyleListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localAttrListeners[_all] !== undefined) {                            loopListener(localAttrListeners[_all], e);                            if (e._stopPropogation === undefined) {                                loopListener(localStyleListeners[_all], e);                            }                        }                        if (e._stopPropogation === undefined && localParentAttrListeners[prop] !== undefined) {                            loopParentListener(localParentAttrListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localParentStyleListeners[prop] !== undefined) {                            loopParentListener(localParentStyleListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localParentAttrListeners[_all] !== undefined) {                            loopParentListener(localParentAttrListeners[_all], e);                            if (e._stopPropogation === undefined) {                                loopParentListener(localParentStyleListeners[_all], e);                            }                        }                    }                    if (e._stopPropogation === undefined && _attrUpdateListeners[prop] !== undefined) {                        loopListener(_attrUpdateListeners[prop], e);                    }                    if (e._stopPropogation === undefined && _styleUpdateListeners[prop] !== undefined) {                        loopListener(_styleUpdateListeners[prop], e);                    }                    if (e._stopPropogation === undefined && _attrUpdateListeners[_all] !== undefined) {                        loopListener(_attrUpdateListeners[_all], e);                        if (e._stopPropogation === undefined) {                            loopListener(_styleUpdateListeners[_all], e);                        }                    }                    if (e._preventDefault !== undefined) return false;                    return true;                }            /* Helper method to loop through listeners and run them */            function loopListener(looper, e) {                var _looper = looper,                    _len = looper.length,                    _e = e,                    _x;                for (_x = 0; _x < _len; _x++) {                    looper[_x](_e);                    if (_e._stopPropogation !== undefined) break;                }            }            /* Helper method to loop through all parent listeners and run them */            function loopParentListener(looper, e) {                var _looper = looper,                    _len = looper.length,                    _e = e,                    _x;                for (_x = 0; _x < _len; _x++) {                    _e.child = _e.target;                    _e.target = looper[_x].parent;                    looper[_x].func(_e);                    if (_e._stopPropogation !== undefined) break;                }            }            /* Helper method to loop through all listeners and return if a method exists */            function loopListenerCheck(looper, func) {                var _looper = looper,                    _len = looper.length,                    _func = func,                    _x;                for (_x = 0; _x < _len; x++) {                    if (_looper[x].toString() === _func.toString()) return true;                }                return false;            }            /* The event object that gets passed to each listener */            function _changeEvent(el, attr, value, oldValue, args, action, type, stopChange) {                this.stopPropagation = function() {                    this._stopPropogation = true;                };                this.preventDefault = function() {                    this._preventDefault = true;                };                this.value = value;                this.oldValue = oldValue;                this.target = el;                this.attr = attr;                this.arguments = args;                this.action = action;                this.child = undefined;                this.type = type;                this.stopChange = stopChange;            }            /* This holds all listeners associated with a particular element */            function _localBinders() {                this._attrListeners = {};                this._attrUpdateListeners = {};                this._styleListeners = {};                this._styleUpdateListeners = {};                this._parentStyleListeners = {};                this._parentStyleUpdateListeners = {};                this._parentAttrListeners = {};                this._parentAttrUpdateListeners = {};                this._injectedStyle = {};            }            /* This is a standard property set overwrite  */            function setStandard(descriptor, key, set, update) {                var _descriptor = descriptor,                    _descGet = _descriptor.get,                    _descSet = _descriptor.set,                    _key = key,                    _set = set,                    _update = update,                    _oldValue;                return function standardSet(v) {                    _oldValue = _descGet.call(this);                    if (_set(this, _key, v, _oldValue, undefined, this._stopChange)) {                        _descSet.call(this, v);                    }                    if (!this._stopChange) {                        _update(this, _key, v, _oldValue);                    }                    this._stopChange = undefined;                }            }            /* This is a standard value set overwrite */            function setValue(descriptor, key, set, update) {                var _descriptor = descriptor,                    _key = key,                    _set = set,                    _update = update,                    _oldValue;                return function valueSet(v) {                    _oldValue = _descriptor.value;                    if (_set(this, _key, v, _oldValue, arguments, this._stopChange)) {                        _descriptor.value = v;                    }                    if (!this._stopChange) {                        _update(this, _key, v, _oldValue, arguments);                    }                    this._stopChange = undefined;                }            }            /* This is a standard function overwrite  */            function setFunction(descriptor, key, set, update) {                var _descriptor = descriptor,                    _descVal = _descriptor.value,                    _key = key,                    _set = set,                    _update = update,                    _action;                return function functionSet() {                    if (_set(this, _key, null, null, arguments, this._stopChange)) {                        _action = _descVal.apply(this, arguments);                    }                    if (!this._stopChange) {                        _update(this, _key, null, null, arguments, _action);                    }                    this._stopChange = undefined;                    return _action;                }            }            /* This overwites a style property */            function setStyle(descriptor, key, set, update, el) {                var _proto = el.style,                    _descriptor = descriptor,                    _key = key,                    _keyCP = key.replace(/([A-Z])/g, "-$1").replace('webkit', '-webkit'),                    _set = set,                    _update = update,                    _el = el,                    _oldValue,                    _value;                return {                    get: function() {                        return _value;                    },                    set: function styleSet(v) {                        _oldValue = _value;                        if (_set(_el, _key, v, _oldValue, undefined, this._stopChange)) {                            _value = v;                            _proto.setProperty(_keyCP, v);                        }                        if (!this._stopChange) {                            _update(_el, _key, v, _oldValue);                        }                        this._stopChange = undefined;                    },                    enumerable: true,                    configurable: true                }            }            /* A helper method that is run for all addListener methods */            function addListener(attr, func, child, update) {                if (typeof func !== 'function') return bind;                var isInput = (['value', 'checked'].indexOf(attr) !== -1),                    isStyle = (_allStyles.indexOf(attr) !== -1),                    listeners;                if (this.toString() !== bind.toString()) {                    if (child) {                        var children = this.querySelectorAll('*'),                            len = children.length,                            listenerObj;                        for (var x = 0; x < len; x++) {                            listenerObj = children[x].attrListeners();                            if (isInput || (attr === _all)) {                                if (children[x].addInputBinding !== undefined) children[x].addInputBinding();                                if (children[x].addInputBoxBinding !== undefined) children[x].addInputBoxBinding();                            }                            if (isStyle) {                                bind.injectStyleProperty(children[x], attr);                                listeners = (update ? '_parentStyleUpdateListeners' : '_parentStyleListeners');                                if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                                listenerObj[listeners][attr].push({                                    parent: this,                                    func: func                                });                            } else {                                if (attr === _all) {                                    listeners = (update ? '_parentStyleUpdateListeners' : '_parentStyleListeners');                                    var len = _allStyles.length;                                    for (var i = 0; i < len; i++) {                                        bind.injectStyleProperty(children[x], _allStyles[i]);                                    }                                    if (listenerObj[listeners][_all] === undefined) listenerObj[listeners][_all] = [];                                    listenerObj[listeners][_all].push({                                        parent: this,                                        func: func                                    });                                }                                listeners = (update ? '_parentAttrUpdateListeners' : '_parentAttrListeners');                                if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                                listenerObj[listeners][attr].push({                                    parent: this,                                    func: func                                });                            }                        }                    } else {                        listenerObj = this.attrListeners();                        if (isStyle) {                            listeners = (update ? '_styleUpdateListeners' : '_styleListeners');                            bind.injectStyleProperty(this, attr);                            if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                            listenerObj[listeners][attr].push(func);                        } else {                            if (isInput || (attr === _all)) {                                if (this.addInputBinding !== undefined) this.addInputBinding();                                if (this.addInputBoxBinding !== undefined) this.addInputBoxBinding();                            }                            if (attr === _all) {                                listeners = (update ? '_styleUpdateListeners' : '_styleListeners');                                var len = _allStyles.length;                                for (var x = 0; x < len; x++) {                                    bind.injectStyleProperty(this, _allStyles[x]);                                }                                if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                                listenerObj[listeners][attr].push(func);                            }                            listeners = (update ? '_attrUpdateListeners' : '_attrListeners');                            if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                            listenerObj[listeners][attr].push(func);                        }                    }                } else {                    if (isInput || (attr === _all)) {                        var inputs = document.querySelectorAll('input, textarea'),                            len = inputs.length;                        for (var x = 0; x < len; x++) {                            if (inputs[x].addInputBinding !== undefined) inputs[x].addInputBinding();                            if (inputs[x].addInputBoxBinding !== undefined) inputs[x].addInputBoxBinding();                        }                    }                    if (isStyle) {                        var els = Array.prototype.slice.call(document.body.querySelectorAll('*')),                            len = (els.length + 1);                        els.unshift(document.body);                        for (var x = 0; x < len; x++) {                            bind.injectStyleProperty(els[x], attr);                        }                        listeners = (update ? _styleUpdateListeners : _styleListeners);                        if (listeners[attr] === undefined) listeners[attr] = [];                        listeners[attr].push(func);                    } else {                        if (attr === _all) {                            var els = Array.prototype.slice.call(document.body.querySelectorAll('*')),                                len = (els.length + 1),                                lenStyles = _allStyles.length;                            els.unshift(document.body);                            for (var x = 0; x < len; x++) {                                for (var i = 0; i < lenStyles; i++) {                                    bind.injectStyleProperty(els[x], _allStyles[i]);                                }                            }                            listeners = (update ? _styleUpdateListeners : _styleListeners);                            if (listeners[attr] === undefined) listeners[attr] = [];                            listeners[attr].push(func);                        }                        listeners = (update ? _attrUpdateListeners : _attrListeners);                        if (listeners[attr] === undefined) listeners[attr] = [];                        listeners[attr].push(func);                    }                }            }            /* A helper method that is ran for all removeListener methods */            function removeListener(attr, func, child, update) {                if (typeof func !== 'function') return bind;                var isInput = (['value', 'checked'].indexOf(attr) !== -1),                    isStyle = (_allStyles.indexOf(attr) !== -1),                    listeners,                    x;                function cut(attr, list) {                    var listenerFuncs = list[attr],                        len = listenerFuncs.length;                    for (x = 0; x < len; x++) {                        if (listenerFuncs[x].toString() === func.toString()) {                            listenerFuncs.splice(x, 1);                        }                    }                }                if (this.toString() !== bind.toString()) {                    if (child) {                        var children = this.querySelectorAll('*'),                            len = children.length;                        if (isStyle) {                            listeners = (update ? '_childStyleUpdateListeners' : '_childStyleListeners');                            cut(attr, this.attrListeners()[listeners]);                            listeners = (update ? '_parentStyleUpdateListeners' : '_parentStyleListeners');                        } else {                            if (attr === _all) {                                listeners = (update ? '_childStyleUpdateListeners' : '_childStyleListeners');                                cut(attr, this.attrListeners()[listeners]);                            }                            listeners = (update ? '_childAttrUpdateListeners' : '_childAttrListeners');                            cut(attr, this.attrListeners()[listeners]);                            listeners = (update ? '_parentAttrUpdateListeners' : '_parentAttrListeners');                        }                        for (x = 0; x < len; x++) {                            var parents = children[x].attrListeners()[listeners][attr],                                parentLen = parents.length;                            for (var i = 0; i < parentLen; i++) {                                if (parents[i].isEqualNode(this)) {                                    parents.slice(i, 1);                                }                            }                            if (attr === _all) {                                listenersStyle = (update ? '_parentStyleUpdateListeners' : '_parentStyleListeners');                                var parents = children[x].attrListeners()[listeners][attr],                                    parentLen = parents.length;                                for (var i = 0; i < parentLen; i++) {                                    if (parents[i].isEqualNode(this)) {                                        parents.slice(i, 1);                                    }                                }                            }                        }                    } else {                        if (isStyle) {                            listeners = (update ? '_styleUpdateListeners' : '_styleListeners');                            cut(attr, this.attrListeners()[listeners]);                        } else {                            if (attr === _all) {                                listeners = (update ? '_styleUpdateListeners' : '_styleListeners');                                cut(attr, this.attrListeners()[listeners]);                            }                            listeners = (update ? '_attrUpdateListeners' : '_attrListeners');                            cut(attr, this.attrListeners()[listeners]);                        }                    }                } else {                    if (isStyle) {                        listeners = (update ? _styleUpdateListeners : _styleListeners);                        cut(attr, listeners);                    } else {                        if (attr === _all) {                            listeners = (update ? _styleUpdateListeners : _styleListeners);                            cut(attr, listeners);                        }                        listeners = (update ? _attrUpdateListeners : _attrListeners);                        cut(attr, listeners);                    }                }            }            /* this method gets attached to all elements for easy listener adding of child events */            function addChildAttrListener(attr, func) {                bind.addAttrListener.call(this, attr, func, true);                return this;            }            /* this method gets attached to all elements for easy listener adding of child update events */            function addChildAttrUpdateListener(attr, func) {                bind.addAttrUpdateListener.call(this, attr, func, true);                return this;            }            /* this method gets attached to all elements for easy listener removal of child events */            function removeChildAttrListener(attr, func) {                bind.removeAttrListener.call(this, attr, func, true);                return this;            }            /* this method gets attached to all elements for easy listener removal of child update events */            function removeChildAttrUpdateListener(attr, func) {                bind.removeAttrUpdateListener.call(this, attr, func, true);                return this;            }            /* This method checks if a listener of this function already exists on a desired attribute */            function hasListener(listener, attr, func) {                var _listeners = this.attrListeners();                if (attr === 'html') attr = 'innerHTML';                if (attr === 'events') attr = 'onclick';                switch (listener) {                    case 'attr':                        if (typeof _listeners._attrListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._attrListeners[attr], func)) return true;                        } else if (typeof _listeners._styleListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._styleListeners[attr], func)) return true;                        } else if (typeof _listeners._parentAttrListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._parentAttrListeners[attr], func)) return true;                        } else if (typeof _listeners._parentStyleListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._parentStyleListeners[attr], func)) return true;                        }                        break;                    case 'attrupdate':                        if (typeof _listeners._attrUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._attrUpdateListeners[attr], func)) return true;                        } else if (typeof _listeners._styleUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._styleUpdateListeners[attr], func)) return true;                        } else if (typeof _listeners._parentAttrUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._parentAttrUpdateListeners[attr], func)) return true;                        } else if (typeof _listeners._parentStyleUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._parentStyleUpdateListeners[attr], func)) return true;                        }                        break;                }                return false;            }            /* sets stopChange Property for stopping update listeners to fire */            function stopChange() {                this._stopChange = true;                return this;            }            /* This is the master constructor, to be ran only once. */            function bind() {                bind.injectPrototypes(Node, 'Node');                bind.injectPrototypes(Element, 'Element');                bind.injectPrototypes(HTMLElement, 'HTMLElement');                bind.injectPrototypes(HTMLInputElement, 'HTMLInputElement');                bind.injectPrototypes(HTMLTextAreaElement, 'HTMLTextAreaElement');                bind.injectPrototypes(Document, 'Document');                var __set = _set,                    __update = _update;                function hasInput(attrListeners) {                    var attrs = ['value', 'checked'],                        _localListeners = attrListeners,                        _localAttr = _localListeners._attrListeners,                        _localUpdateAttr = _localListeners._attrUpdateListeners,                        _localParentAttr = _localListeners._parentAttrListeners,                        _localParentUpdateAttr = _localListeners._parentAttrUpdateListeners,                        has = false;                    if (_attrListeners[_all] !== undefined || _attrUpdateListeners[_all] !== undefined) {                        has = true;                    }                    if (has !== true && _localAttr[_all] !== undefined ||                        _localUpdateAttr[_all] !== undefined ||                        _localParentAttr[_all] !== undefined ||                        _localParentUpdateAttr[_all] !== undefined) {                        has = true;                    }                    if (has !== true) {                        for (var x = 0; x < attrs.length; x++) {                            if (_attrListeners[attrs[x]] !== undefined ||                                _attrUpdateListeners[attrs[x]] !== undefined ||                                _localAttr[attrs[x]] !== undefined ||                                _localUpdateAttr[attrs[x]] !== undefined ||                                _localParentAttr[attrs[x]] !== undefined ||                                _localParentUpdateAttr[attrs[x]] !== undefined) {                                has = true;                                break;                            }                        }                    }                    return has;                }                function getStyles(arr, styles) {                    var x,                        _arr = arr,                        _styles = styles,                        len = styles.length;                    for (x = 0; x < len; x++) {                        if (_arr.indexOf(_styles[x]) === -1) {                            _arr.push(_styles[x]);                        }                    }                    return _arr;                }                function hasStyle(attrListeners) {                    var _globalStyle = Object.keys(_styleListeners),                        _globalStyleUpdate = Object.keys(_styleUpdateListeners),                        _localListeners = attrListeners,                        _localStyle = Object.keys(_localListeners._styleListeners),                        _localUpdateStyle = Object.keys(_localListeners._styleUpdateListeners),                        _localParentStyle = Object.keys(_localListeners._parentStyleListeners),                        _localParentUpdateStyle = Object.keys(_localListeners._parentStyleUpdateListeners),                        has = [];                    if (_globalStyle.length !== 0 ||                        _globalStyleUpdate.length !== 0) {                        has = getStyles(has, _globalStyle);                        has = getStyles(has, _globalStyleUpdate);                    }                    if (has.length !== 0 && _localParentStyle.length !== 0 ||                        _localParentUpdateStyle.length !== 0) {                        has = getStyles(has, _localParentStyle);                        has = getStyles(has, _localParentUpdateStyle);                    }                    if (has.indexOf(_all) !== -1) has = _allStyles;                    return has;                }                function copyListeners(listeners, copyTo) {                    var listenerProps = Object.keys(listeners),                        _currProp,                        _currListener;                    for (var x = 0, len = listenerProps.length; x < len; x++) {                        _currProp = listenerProps[x];                        if (copyTo[_currProp] === undefined) {                            copyTo[_currProp] = listeners[_currProp].slice();                        } else {                            for (var i = 0, lenI = listeners[_currProp].length; i < lenI; i++) {                                _currListener = listeners[_currProp][i];                                copyTo[_currProp].push(_currListener);                            }                        }                    }                }                function reSync(e) {                    if (e.target.nodeType !== 3 && e.target.nodeType !== 8) {                        var attrListeners = e.target.attrListeners(),                            _hasInput = hasInput(attrListeners),                            _hasStyle = hasStyle(attrListeners),                            _hasStyleLen = _hasStyle.length,                            _parentAttr,                            _parentAttrUpdate,                            _parentStyle,                            _parentStyleUpdate,                            _listeners,                            nodes = [],                            len,                            outer = ((e.attr === 'outerHTML' || e.attr === 'outerText') ? e.attr : undefined),                            target = e.target                        if (outer !== undefined) {                            e.attr = 'appendChild',                                e.arguments = [e.target];                            e.target = e.target.parentElement;                        }                        if (_hasInput) {                            if (e.attr === 'appendChild' && e.arguments[0].nodeType !== 3 && e.arguments[0].nodeType !== 8) {                                nodes = Array.prototype.slice.call(e.arguments[0].querySelectorAll('input,textarea'));                                if (e.arguments[0].tagName === 'INPUT' || e.arguments[0].tagName === 'TEXTAREA') {                                    nodes.unshift(e.arguments[0])                                }                            } else {                                nodes = Array.prototype.slice.call(e.target.querySelectorAll('input,textarea'));                            }                            len = nodes.length;                            for (var x = 0; x < len; x++) {                                if (nodes[x].addInputBinding !== undefined) nodes[x].addInputBinding();                                if (nodes[x].addInputBoxBinding !== undefined) nodes[x].addInputBoxBinding();                            }                        }                        if (e.attr === 'appendChild' && e.arguments[0].nodeName !== '#text' && e.arguments[0].nodeName !== '#comment') {                            nodes = Array.prototype.slice.call(e.arguments[0].querySelectorAll('*'));                            nodes.unshift(e.arguments[0]);                            _parentAttr = e.target.__kb._parentAttrListeners;                            _parentAttrUpdate = e.target.__kb._parentAttrUpdateListeners;                            _parentStyle = e.target.__kb._parentStyleListeners;                            _parentStyleUpdate = e.target.__kb._parentStyleUpdateListeners;                        } else {                            nodes = Array.prototype.slice.call(e.target.querySelectorAll('*'));                            _parentAttr = e.target.__kb._parentAttrListeners;                            _parentAttrUpdate = e.target.__kb._parentAttrUpdateListeners;                            _parentStyle = e.target.__kb._parentStyleListeners;                            _parentStyleUpdate = e.target.__kb._parentStyleUpdateListeners;                        }                        len = nodes.length;                        for (var x = 0; x < len; x++) {                            if (_hasStyleLen !== 0) {                                for (var i = 0; i < _hasStyleLen; i++) {                                    bind.injectStyleProperty(nodes[x], _hasStyle[i]);                                }                            }                            _listeners = nodes[x].attrListeners();                            copyListeners(_parentAttr, _listeners._parentAttrListeners);                            copyListeners(_parentAttrUpdate, _listeners._parentAttrUpdateListeners);                            copyListeners(_parentStyle, _listeners._parentStyleListeners);                            copyListeners(_parentStyleUpdate, _listeners._parentStyleUpdateListeners);                        }                        if (outer !== undefined) {                            e.attr = outer;                            e.target = target;                            e.arguments = [];                        }                    }                }                function checkAttr(e) {                    var oldAttr = e.target.attributes[e.arguments[0]],                        old = (oldAttr !== undefined ? oldAttr.value : ""),                        val = (e.attr === 'setAttribute' ? e.arguments[1] : "");                    if (!__set(e.target, e.arguments[0], val, old, [val])) {                        e.preventDefault();                    }                }                function checkAttrUpdate(e) {                    var oldAttr = e.target.attributes[e.arguments[0]],                        old = (oldAttr !== undefined ? oldAttr.value : ""),                        val = (e.attr === 'setAttribute' ? e.arguments[1] : "");                    __update(e.target, e.arguments[0], val, old, [val]);                }                //for keeping binds with inputs                bind.addAttrUpdateListener('appendChild', reSync);                bind.addAttrUpdateListener('removeChild', reSync);                bind.addAttrUpdateListener('innerHTML', reSync);                bind.addAttrUpdateListener('outerHTML', reSync);                bind.addAttrUpdateListener('innerText', reSync);                bind.addAttrUpdateListener('outerText', reSync);                bind.addAttrUpdateListener('textContent', reSync);                //allows for html attribute changes to be listened to just like properties                bind.addAttrListener('setAttribute', checkAttr);                bind.addAttrListener('removeAttribute', checkAttr);                bind.addAttrUpdateListener('setAttribute', checkAttrUpdate);                bind.addAttrUpdateListener('removeAttribute', checkAttrUpdate);                return bind;            }            bind.injectPrototypeProperty = function(obj, key, injectName, set, update) {                var _proto = obj.prototype,                    _descriptor = Object.getOwnPropertyDescriptor(_proto, key),                    _injectName = (injectName || obj.toString().split(/\s+/)[1].split('{')[0].replace('()', '')),                    _injectedObj = _injected[_injectName],                    __set = (set || _set),                    __update = (update || _update);                if (_proto.attrListeners === undefined) {                    _proto = {};                    _proto.attrListeners = (function() {                        if (this.__kb === undefined) {                            this.__kb = new _localBinders();                        }                        return this.__kb;                    }).bind(_proto);                    _proto.addAttrListener = bind.addAttrListener;                    _proto.addAttrUpdateListener = bind.addAttrUpdateListener;                    _proto.addChildAttrListener = addChildAttrListener;                    _proto.addChildAttrUpdateListener = addChildAttrUpdateListener;                    _proto.hasListener = hasListener;                    _proto.removeAttrListener = bind.removeAttrListener;                    _proto.removeAttrUpdateListener = bind.removeAttrUpdateListener;                    _proto.removeChildAttrListener = removeChildAttrListener;                    _proto.removeChildAttrUpdateListener = removeChildAttrUpdateListener;                    _proto.stopChange = stopChange;                }                if (_injectedObj === undefined) {                    _injected[_injectName] = {                        obj: obj,                        proto: _proto,                        descriptors: {},                        set: undefined,                        update: undefined                    };                    _injectedObj = _injected[_injectName];                    _injectedObj.set = __set;                    _injectedObj.update = __update;                }                if (_injectedObj.descriptors[key] === undefined) _injectedObj.descriptors[key] = _descriptor;                if (_descriptor.configurable) {                    if (_descriptor.set !== undefined) {                        Object.defineProperty(_proto, key, {                            get: _descriptor.get,                            set: setStandard(_descriptor, key, __set, __update),                            enumerable: true,                            configurable: true                        });                    } else if (typeof _descriptor.value === 'function') {                        Object.defineProperty(_proto, key, {                            value: setFunction(_descriptor, key, __set, __update),                            writable: true,                            enumerable: true,                            configurable: true                        });                    } else if (_descriptor.value !== undefined) {                        Object.defineProperty(_proto, key, {                            get: function() {                                return _descriptor.value;                            },                            set: setValue(_descriptor, key, __set, __update),                            enumerable: true,                            configurable: true                        });                    }                }                return bind;            }            bind.injectStyleProperty = function(el, key, set, update) {                var _proto = el.style,                    _descriptor = Object.getOwnPropertyDescriptor(_proto, key),                    _injectedObj = el.attrListeners().injectedStyle,                    __set = (set || _set),                    __update = (update || _update);                if (_injectedObj === undefined) {                    el.attrListeners().injectedStyle = {                        obj: el,                        proto: _proto,                        descriptors: {},                        set: undefined,                        update: undefined                    };                    el.attrListeners().injectedStyle.set = __set;                    el.attrListeners().injectedStyle.update = __update;                    _injectedObj = el.attrListeners().injectedStyle;                }                if (_injectedObj.descriptors[key] === undefined) _injectedObj.descriptors[key] = _descriptor;                if (_descriptor.configurable) {                    Object.defineProperty(_proto, key, setStyle(_descriptor, key, __set, __update, el));                }                return bind;            }            bind.injectPrototypes = function(obj, injectName, set, update) {                var _proto = obj.prototype,                    _injectName = (injectName || obj.toString().split(/\s+/)[1].split('{')[0].replace('()', '')),                    _injectedObj = _injected[_injectName],                    _keys = Object.getOwnPropertyNames(_proto),                    __set = (set || _set),                    __update = (update || _update),                    _descriptors,                    x;                if (_proto.attrListeners === undefined) {                    _proto.attrListeners = function() {                        if (this.__kb === undefined) {                            this.__kb = new _localBinders();                        }                        return this.__kb;                    }                    _proto.addAttrListener = bind.addAttrListener;                    _proto.addAttrUpdateListener = bind.addAttrUpdateListener;                    _proto.addChildAttrListener = addChildAttrListener;                    _proto.addChildAttrUpdateListener = addChildAttrUpdateListener;                    _proto.removeAttrListener = bind.removeAttrListener;                    _proto.removeAttrUpdateListener = bind.removeAttrUpdateListener;                    _proto.removeChildAttrListener = removeChildAttrListener;                    _proto.removeChildAttrUpdateListener = removeChildAttrUpdateListener;                    _proto.hasListener = hasListener;                    _proto.stopChange = stopChange;                }                if (_injectedObj === undefined) {                    _injected[_injectName] = {                        obj: obj,                        proto: _proto,                        descriptors: {},                        set: undefined,                        update: undefined                    };                    _injectedObj = _injected[_injectName];                    _injectedObj.set = __set;                    _injectedObj.update = __update;                }                _descriptors = _injected[_injectName].descriptors;                for (x = 0; x < _keys.length; x += 1) {                    if (_descriptors[_keys[x]] === undefined) {                        bind.injectPrototypeProperty(obj, _keys[x], _injectName, __set, _update);                    }                }                if (_keys.indexOf('value') !== -1) {                    function keyDown(e) {                        var isCheck,                            oldCheck,                            oldValue,                            value;                        if (this.type === 'checkbox' || this.type === 'radio') {                            oldCheck = this.checked;                            isCheck = true;                        }                        oldValue = (isCheck ? (typeof this.checked === 'string' ? this.checked : (this.checked ? "true" : "false")) : this.value);                        setTimeout((function() {                            value = (isCheck ? (typeof this.checked === 'string' ? this.checked : (this.checked ? "true" : "false")) : this.value);                            if (isCheck) {                                if (!_injectedObj.set(this, 'checked', this.checked, oldValue)) {                                    _descriptors['checked'].set.call(this, oldValue);                                } else {                                    _injectedObj.update(this, 'checked', this.checked, oldValue);                                }                            }                            if (this.value !== value) this.value = value;                            if (!_injectedObj.set(this, 'value', this.value, oldValue)) {                                _descriptors['value'].set.call(this, oldValue);                            } else {                                _injectedObj.update(this, 'value', this.value, oldValue);                            }                        }).bind(this), 0);                    }                    _proto.removeInputBinding = function() {                        this.attrListeners()._onkeydown = undefined;                        this.removeEventListener('keydown', keyDown);                    }                    _proto.addInputBinding = function() {                        this.attrListeners()._onkeydown = true;                        this.addEventListener('keydown', keyDown);                    }                    _proto.removeInputBoxBinding = function() {                        this.attrListeners()._onmousedown = undefined;                        this.removeEventListener('mouseup', keyDown);                    }                    _proto.addInputBoxBinding = function() {                        this.attrListeners()._onmousedown = true;                        this.addEventListener('mouseup', keyDown);                    }                }                return bind;            }            bind.addAttrListener = function(attr, func, child) {                if (attr === 'html') {                    for (var x = 0, len = _texts.length; x < len; x++) {                        addListener.call(this, _texts[x], func, child, false);                    }                } else if (attr === 'events') {                    for (var x = 0, len = _allEvents.length; x < len; x++) {                        addListener.call(this, _allEvents[x], func, child, false);                    }                } else {                    addListener.call(this, attr, func, child, false);                }                return this;            }            bind.addAttrUpdateListener = function(attr, func, child) {                if (attr === 'html') {                    for (var x = 0, len = _texts.length; x < len; x++) {                        addListener.call(this, _texts[x], func, child, true);                    }                } else if (attr === 'events') {                    for (var x = 0, len = _allEvents.length; x < len; x++) {                        addListener.call(this, _allEvents[x], func, child, true);                    }                } else {                    addListener.call(this, attr, func, child, true);                }                return this;            }            bind.removeAttrListener = function(attr, func, child) {                if (attr === 'html') {                    for (var x = 0, len = _texts.length; x < len; x++) {                        removeListener.call(this, _texts[x], func, child, false);                    }                } else if (attr === 'events') {                    for (var x = 0, len = _allEvents.length; x < len; x++) {                        removeListener.call(this, _allEvents[x], func, child, false);                    }                } else {                    removeListener.call(this, attr, func, child, false);                }                return this;            }            bind.removeAttrUpdateListener = function(attr, func, child) {                if (attr === 'html') {                    for (var x = 0, len = _texts.length; x < len; x++) {                        removeListener.call(this, _texts[x], func, child, true);                    }                } else if (attr === 'events') {                    for (var x = 0, len = _allEvents.length; x < len; x++) {                        removeListener.call(this, _allEvents[x], func, child, true);                    }                } else {                    removeListener.call(this, attr, func, child, true);                }                return this;            }            bind.hasListener = function(listener, attr, func) {                if (attr === 'html') attr = 'innerHTML';                if (attr === 'events') attr = 'onclick';                switch (listener) {                    case 'attr':                        if (typeof _attrListeners[attr] !== undefined) {                            if (loopListenerCheck(_attrListeners[attr], func)) return true;                        } else if (typeof _styleListeners[attr] !== undefined) {                            if (loopListenerCheck(_styleListeners[attr], func)) return true;                        }                        break;                    case 'attrupdate':                        if (typeof _attrUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_attrUpdateListeners[attr], func)) return true;                        } else if (typeof _styleUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_styleUpdateListeners[attr], func)) return true;                        }                        break;                }                return false;            }            bind.injectedPrototypes = function() {                return _injected;            }            return bind;        }        if (typeof define === "function" && define.amd) {            define('KB', CreateKB); //global KM define in browser        }        return CreateKB;    }())    var CreateKonnektRTF = (function() {        function CreaKonnektRTF() {            var _base = '',                _onChange = function() {};            function KonnektRTF(name) {                if (name.length === 0) name = _base;                document.body.innerHTML = "<" + name + "></" + name + ">";                _onChange(name);                return KonnektRTF;            }            KonnektRTF.base = function(v) {                if (v === undefined) return _base;                _base = (typeof v === 'string' ? v : _base);                return KonnektRTF;            }            KonnektRTF.onChange = function(v) {                if (v === undefined) return _onChange;                _onChange = (typeof v === 'function' ? v : _onChange);                return KonnektRTF;            }            KonnektRTF.watch = function(v) {                if (v) {                    window.onhashchange = function() {                        KonnektRTF(window.location.hash.replace('#', ''));                    }                } else {                    window.onhashchange = null;                }                return KonnektRTF;            }            return KonnektRTF;        }        return CreaKonnektRTF;    }());    var CreateKonnektMP = (function(kb) {        function CreateKonnektMP() {            var _templates = {},                _reNodes = /(<\/.*?>)/g,                _kb = kb().call(),                _domevents = Object.keys(HTMLElement.prototype)                .filter(function(v) {                    return v.indexOf('on') === 0                }),                _start = "{{",                _end = "}}",                _pipe = "|",                _events = {                    unknown: []                }            function KonnektMP(node, postpone) {                /* Name of the component */                this.name = node.tagName.toLowerCase();                /* template of the component */                this.template = _templates[this.name] || '<div class="missing_component">Unknown Component</div>';                /* original node */                this.node = node;                /* document fragment to prevent reflow for faster browser rendering */                this.fragment = document.createDocumentFragment();                /* wrapper div for placing components inside */                this.wrapper = document.createElement('div');                /* set wrapper html and define class */                this.wrapper.className = "Wrapper Wrapper__" + this.name;                if (!postpone) this.wrapper.innerHTML = this.template;                /* append wrapper to fragment for prep to append to dom */                this.fragment.appendChild(this.wrapper);                /* map nodes with their bindings */                if (!postpone) this.maps = this.map(this.wrapper);                if (!postpone) this.wrapper.kb_maps = this.maps;            }            /* Prototypes */            /* returns a bind map object in relation to the passed nodes */            KonnektMP.prototype.map = function(node) {                var binds = {};                /* This method is a recursive childnode search, searches for text nodes and attributes for getting binds */                function loopMap(childNodes) {                    childNodes = Array.prototype.slice.call(childNodes);                    for (var x = 0, len = childNodes.length; x < len; x++) {                        /* make sure we dont look at other components, but only this one */                        if (childNodes[x].kb_maps === undefined && childNodes[x].nodeType !== 8) {                            /* add mapper refrence so from any node we can always go back to root */                            childNodes[x].kb_mapper = node;                            /* check if node is a text node */                            if (childNodes[x].nodeType === 3) {                                bindTexts(childNodes[x], binds);                            }                            /* if it isnt then only check attributes for binds */                            else {                                bindAttrs(childNodes[x], binds);                            }                            /* if this childnode has other children nodes then we run recursive */                            if (childNodes[x].childNodes && childNodes[x].childNodes.length !== 0) loopMap(childNodes[x].childNodes);                        }                    }                }                loopMap(node.childNodes);                return binds;            }            /* allows appending a new filter to a bind with a requested key */            /*KonnektMP.prototype.addFilter = function(name,filterName)            {              if(this.maps[name] !== undefined)              {                this.maps[name].forEach(function(map){                  map.filters.push(filterName);                  map.refresh();                });              }              return this;            }*/            /* removes a filter name from a desired bind with requested key */            /*KonnektMP.prototype.removeFilter = function(name,filterName)            {              if(this.maps[name] !== undefined)              {                this.maps[name].forEach(function(map){                  map.filters.splice(this.maps[name].filters.indexOf(filterName),1);                  map.refresh();                });              }              return this;            }*/            /* allows for swapping one filter out for another on a bind */            /*KonnektMP.prototype.swapFilter = function(name,oldFilter,newFilter)            {              if(this.maps[name] !== undefined)              {                this.maps[name].forEach(function(map){                  map.filters.splice(this.maps[name].filters.indexOf(oldFilter),1,newFilter);                  map.refresh();                })              }              return this;            }*/            /* Closure based helper methods */            function getMatch() {                return new RegExp('(\\' + _start.split('').join('\\') + ')(.*?)(\\' + _end.split('').join('\\') + ')', 'g')            }            function getForMatch() {                return new RegExp('(\\' + _start.split('').join('\\') + ')(.*?)(for)(.*?)(loop)(.*?)(\\' + _end.split('').join('\\') + ')', 'g');            }            /* checks for bind matches in a text node and parses inserts them into the binds object for returning */            function bindTexts(node, binds) {                /* the actual text */                var text = node.textContent,                    /* if the parent element is a component then we need to treat it as a single instance map */                    isUnknown = (node.parentElement instanceof HTMLUnknownElement);                /* matches an array of _start and end looking for binds in the text */                if (text.match(getMatch())) {                    /*specifies bind type: component|for|text */                    var type = (isUnknown ? 'component' : (text.match(getForMatch()) ? 'for' : 'text')),                        /* The bind constructor: @Params (type)component|for|text, (text)fullString, (listener) property, (property) property, (target) local node, (Element) real Node/Element */                        binder = getBindObject(binds, type, text, splitText(text), (isUnknown ? '' : 'textContent'), 'textContent', node, node.parentElement);                    /* lop each bind string eg: ["Hello","{{name}}",", ","{{greeting}}"] */                    for (var x = 0, len = binder.prototype.bindText.length; x < len; x++) {                        var btext = binder.prototype.bindText[x];                        /* if this is a bind */                        if (btext.indexOf(_start) === 0) {                            /* create new bind object and attach to the binds list for returning */                            var bind = new binder(btext);                            binder.prototype.bindText[x] = bind;                            if (binds[bind.key] === undefined) binds[bind.key] = [];                            bind.id = binds[bind.key].length;                            binds[bind.key].push(bind);                        }                    }                }            }            function bindAttrs(node, binds) {                /* all attributes of the node */                var attrs = Array.prototype.slice.call(node.attributes),                    /* if the parent element is a component then we need to treat it as a single instance map */                    isUnknown = (node instanceof HTMLUnknownElement),                    attr;                for (var i = 0, lenn = attrs.length; i < lenn; i++) {                    attr = attrs[i];                    /* matches an array of _start and end looking for binds in the attribute value */                    if (attr.value.match(getMatch())) {                        /*specifies bind type: component|attribute */                        var type = (isUnknown ? 'component' : 'attribute'),                            /* The bind constructor: @Params (type)component|for|text, (text)fullString, (listener) property, (property) property, (target) local node, (Element) real Node/Element */                            binder = getBindObject(binds, type, attr.value, splitText(attr.value), (isUnknown ? '' : attr.name), 'value', attr, node);                        /* lop each bind string eg: ["Hello","{{name}}",", ","{{greeting}}"] */                        for (var x = 0, len = binder.prototype.bindText.length; x < len; x++) {                            var btext = binder.prototype.bindText[x];                            /* if this is a bind */                            if (btext.indexOf(_start) === 0) {                                /* create new bind object and attach to the binds list for returning */                                var bind = new binder(btext);                                binder.prototype.bindText[x] = bind;                                if (binds[bind.key] === undefined) binds[bind.key] = [];                                binds[bind.key].push(bind);                                bind.id = (binds[bind.key].length - 1);                            }                        }                    }                }            }            /* Mapping Objects */            /* returns a new instancer of a bindObject, that way we can keep prototypes among multiple binds */            function getBindObject(binds, type, text, bindtext, listener, prop, target, element) {                var isEvent = ((type === 'attribute' && _domevents.indexOf(target.name) !== -1) || (type === 'component' && target.name && _domevents.indexOf(target.name) !== -1)),                    isInput = (element.tagName.toLowerCase() === 'input'),                    isRadio = (element.type === 'radio' || element.type === 'check');                if (isEvent) element.stopChange().removeAttribute(target.name);                function bind(b) {                    var _forData = (type === 'for' ? splitFor(b) : []),                        self = this;                    this.key = (type !== 'for' ? splitKey(b) : _forData[0]);                    this.localKey = this.key.split('.').pop();                    this.filterNames = splitFilters(b);                    this.component = (type === 'for' ? _forData[1] : undefined);                    this.id = 0;                    this.isEvent = isEvent;                    this.isInput = isInput;                    this.isRadio = isRadio;                    /* updates prototype bind text to have the local object inside the array in replacement of string text */                    this.__proto__.bindText = this.__proto__.bindText.map(function(v) {                        return (v === b ? this : v);                    });                    this.__proto__.bindMaps.push(this);                    /* This handles value setting of the property, by setting this the dom is automatically updated */                    Object.defineProperties(this, {                        value: setBindDescriptor(bindGet, bindSet, true, true)                    });                    /* used to update a data set if it was connected */                    this.updateData = function(e) {                        if (self.isConnected && self._data) {                            if (typeof e !== 'object' || e.value === undefined) e = {                                value: e                            };                            if (typeof self._data.stopChange === 'function') {                                self._data.stopChange().set(self.key, e.value);                            } else {                                /* **FUTURE** allow standard object setting */                            }                        }                    };                    /* used to update the dom if the data set has events that can be connected */                    this.updateDom = function(e) {                        self.refresh();                    };                    /* used for updating loops */                    this.updateLoop = function(e) {                        if (self.kb_loop) {                            self.loop(e, self.kb_loop);                        }                    };                }                /* define prototypes */                Object.defineProperties(bind.prototype, {                    refresh: setDescriptor(refresh),                    connect: setDescriptor(connect),                    deleteMap: setDescriptor(deleteMap),                    loop: setDescriptor(loop),                    unsync: setDescriptor(unsync),                    unconnect: setDescriptor(unconnect),                    isSynced: setDescriptor(isSynced),                    type: setDescriptor(type),                    text: setDescriptor(text, true),                    bindText: setDescriptor(bindtext, true),                    bindNames: setDescriptor((type === 'for' ? [splitFor(bindtext[0])[0]] : splitBindNames(bindtext)), true),                    bindMaps: setDescriptor([], true),                    bindListener: setDescriptor((isEvent ? listener.toLowerCase() : listener)),                    bindProperty: setDescriptor((isEvent ? target.name.toLowerCase() : prop)),                    bindTarget: setDescriptor(target, true),                    element: setDescriptor(element, true),                    _data: setDescriptor({}, true),                    filters: setDescriptor({}, true),                    maps: setDescriptor(binds, true)                });                return bind            }            /* Bind Prototypes */            /* used for value to get current value */            function bindGet() {                return (this._data.get ? this._data.get(this.key) : '');            }            /* used for value to set and refresh current value */            function bindSet(v) {                if (this._data.set) this._data.stopChange().set(this.key, v);            }            /* checks if the bind element has been removed from the dom */            function isSynced() {                /* parentElement will 'null' if this element is no longer on the dom */                if (!this.element.parentElement) return this.unsync();                return !!this.element.parentElement;            }            function filterValue(target, bindText) {                function filter(target, bindText) {                    return bindText.reduce(function(c, v) {                        /* while reducing bindTexts if index is standard string then attach, else we need to run value through filters prior to attaching */                        return c + (typeof v === 'string' ? v : (v.filterNames.length === 0 ? v.value : v.filterNames.reduce(function(v, f) {                            if (target.filters !== undefined) {                                if (target.filters[f] !== undefined) {                                    return target.filters[f](v);                                } else {                                    console.warn("there is no filter by the name %o in the data model filters %o", f, Object.keys(target.filters));                                    return v;                                }                            }                            console.error('Somehow filters object was not added to the mapping via .connect() method, please see dev')                            return v;                        }, v.value)));                    }, "");                }                if (bindText.length === 1) {                    if (typeof bindText[0].value !== 'function' && typeof bindText[0].value !== 'object') {                        return filter(target, bindText);                    } else {                        return bindText[0].value;                    }                } else {                    return filter(target, bindText);                }            }            function filterDataSet(dataset, bind) {                for (var x = 0, len = bind.filterNames.length; x < len; x++) {                    dataset = bind.filters[bind.filterNames[x]](dataset);                }                return dataset;            }            /* refreshes the tied dom value */            function refresh() {                var self = this;                if (this.type !== 'for') {                    /* check if this is an event */                    if (!this.isEvent) {                        if (this.type === 'component') {                            /* if this is a component binding we need to add the value to post data for being propagated to the component view model */                            if (!this.element.k_post) this.element.k_post = {};                            this.element.k_post[(this.bindProperty === 'textContent' ? 'innerHTML' : this.bindTarget.name)] = filterValue(this, this.bindText);                        } else {                            if (this.key === 'innerHTML') {                                this.bindTarget[this.bindProperty] = "";                                for (var x = 0, len = this.value.length; x < len; x++) {                                    this.element.stopChange().appendChild(this.value[x]);                                }                            } else {                                /* target is either 'attributeNode' or a textNode, bindProperty should either be 'textContent' or 'value' */                                this.bindTarget[this.bindProperty] = filterValue(this, this.bindText);                                if (this.isInput) {                                    this.element.stopChange()[this.bindTarget.name] = filterValue(this, this.bindText);                                }                            }                        }                    } else {                        /* we assign directly as a property */                        this.element.stopChange()[this.bindProperty] = this.bindText[0].value;                    }                }                return this;            }            /* connects a data set up to the current map */            function connect(vm) {                var self = this;                /* sets local data passed data and sets local filters to data filters */                this.__proto__._data = vm;                this.__proto__.filters = (vm.filters !== undefined ? vm.filters : this.filters);                for (var x = 0, len = this.bindNames.length; x < len; x++) {                    /* as we loop throught the bind names we check if 'konnektdt' lib is being used, if so we add the appropriate listeners for the data */                    if (vm.addDataUpdateListener) {                        /* if data set does not exist we create it */                        if (!vm.exists(this.bindNames[x])) {                            console.warn("No property by the name %o exists on this data set %o", this.bindNames[x], vm);                            vm.add(this.bindNames[x], (this.value));                        }                        /* update value with data set value, runs refresh command */                        this.refresh();                        if (this.type !== 'component' && this.type !== 'for') {                            this.isConnected = true;                            vm.getLayer(this.key).addDataUpdateListener(this.bindNames[x], this.updateDom);                        }                        /* bind to array change listeners methods */                        else if (this.type === 'for' && vm.addDataUpdateListener) {                            /* clear html for the list */                            this.element.stopChange().innerHTML = "";                            vm.getLayer(this.key).addDataMethodUpdateListener(this.updateLoop)                                .addDataDeleteListener(this.updateLoop);                        }                    } else {                        /* **FUTURE** allow standard object setting */                    }                }                if (this.bindText.length === 1 && (this.type === 'text' || this.type === 'attribute' || this.isEvent)) this.element.addAttrUpdateListener((this.type === 'text' ? 'html' : this.bindListener), this.updateData);                return this;            }            /* loops through all maps and reconnects them to another data source */            function loopConnect(maps) {                for (var x = 0, keys = Object.keys(maps), len = keys.length; x < len; x++) {                    for (var i = 0, lenn = maps[keys[x]].length; i < lenn; i++) {                        //maps[keys[x]][i].__proto__._data = data;                        maps[keys[x]][i].unconnect().connect(maps[keys[x]][i]._data);                    }                }            }            /* loop creates component nodes based on data */            function loop(e, cb) {                var self = this;                /* this is used in cases where data changes */                if (typeof e === 'function') this.kb_loop = e;                /* apply filters to the list */                filterDataSet(this._data.get(this.key), this);                /* This is an initial loop for initially creating the items */                if (typeof e === 'function') {                    /* loop through the data adding the component nodes and their post data */                    for (var x = 0, len = this._data.get(this.key).length; x < len; x++) {                        var el = document.createElement(this.component);                        el.k_post = this._data.get(this.key)[x];                        el.k_post.k_id = x;                        el.kb_wrapper = this.element.kb_wrapper;                        this.element.stopChange().appendChild(el);                        /* fire callback after it has finished */                        e(el);                    }                }                /* we have a new item that needs added */                else if (e.type === 'postset' && (typeof e.oldValue === 'undefined' || (typeof e.oldValue === 'string' && e.oldValue.length === 0))) {                    var el = document.createElement(self.component),                        length = this.element.children.length;                    el.k_post = this._data.get(this.key)[e.key];                    el.kb_wrapper = this.element.kb_wrapper;                    /* if its the last item then just append */                    if (parseInt(e.key) >= length) {                        this.element.stopChange().appendChild(el);                    }                    /* if not then insert into desired location */                    else {                        this.element.stopChange().insertBefore(el, this.element.children[e.key]);                    }                    if (typeof cb === 'function') cb(el);                }                /* we have an item that needs deleted */                else if (e.event === 'delete') {                    this.element.stopChange().removeChild(this.element.children[e.key]);                }                /* its a standard reorganization update */                else if (e.type !== 'postpush') {                    /*this.element.stopChange().innerHTML = "";                    for(var x=0,len=this._value.length;x<len;x++)                    {                      var el = document.createElement(this.component);                          el.k_post = this._value[x];                          el.k_post.k_id = x;                          el.kb_wrapper = this.element.kb_wrapper;                          this.element.stopChange().appendChild(el);                          if(cb) cb(el);                    }*/                    for (var x = 0, len = this._data.get(this.key).length; x < len; x++) {                        var _curr = this.element.children[x].kb_viewmodel;                        //loopConnect(this.element.children[x].kb_maps,this.element.children[this.element.children[x].kb_viewmodel.k_id].kb_viewmodel);                        for (var i = 0, keys = Object.keys(_curr.pointers), lenn = keys.length; i < lenn; i++) {                            /* flush events */                            //_curr.kb_viewmodel.pointers[keys[i]].key = x;                            /*(function(obj,x,key){                              Object.defineProperty(obj.element.children[x].kb_viewmodel,key,{                                get:function(){return obj._data.get(obj.key)[x][key]},                                set:function(v){                                  (this._stopChange ? obj._data.get(obj.key)[x].stopChange() : obj._data.get(obj.key)[x])[key] = v;                                  this._stopChange = undefined;                                }                              });                            }(this,x,keys[i]));*/                            //this.element.children[x].kb_viewmodel.del(keys[i]);                            //this.element.children[x].kb_viewmodel.stopChange().addPointer(this._data.get(this.key)[x],keys[i]);                            //this.element.children[x].kb_viewmodel.stopChange()[keys[i]] = this._value[x][keys[i]];                        }                        loopConnect(this.element.children[x].kb_maps);                    }                }            }            /* deletes the map from the maps object */            function deleteMap() {                this.maps[this.key].splice(this.id, 1);                return this;            }            function unconnect(id) {                for (var x = 0, len = this.bindNames.length; x < len; x++) {                    this._data.getLayer(this.key).removeDataUpdateListener(this.bindNames[x], this.updateDom);                }                return this;            }            /* acts like a deconstructor if the element happens to be unsynced */            function unsync() {                var self = this;                /* we need to remove all data listeners if they exist so they are not ran on update */                for (var x = 0, len = this.bindNames.length; x < len; x++) {                    if (this._data.removeDataUpdateListener) {                        if (this.type === 'for') {                            this._data.getLayer(this.key).removeDataMethodUpdateListener('*', this.updateLoop)                                .removeDataDeleteListener(self.updateLoop);                        } else if (this.type !== 'component') {                            this._data.getLayer(this.key).removeDataUpdateListener(this.bindNames[x], this.updateDom);                        }                    }                }                /* also remove element listeners */                this.element.removeAttrUpdateListener((this.type === 'text' ? 'html' : this.bindListener), this.updateData);                /* clear all tied shared objects so GC can pick up this object for destroying */                this.maps[this.key].splice(this.id, 1);                for (var x = 0, len = this.maps[this.key].length; x < len; x++) {                    this.maps[this.key][x].id = x;                }                this.bindNames = null;                this.maps = null;                this.bindMaps = null;                this.__proto__._data = null;                this.__proto__.element = null;                this.__proto__.filters = null;                this.__proto__.bindTarget = null;                this.__proto__.bindText = null;                this.__proto__.bindNames = null;                this.__proto__.element = null;                this.__proto__.maps = null;                this.__proto__.bindMaps = null;                return this;            }            /* Text Splitters */            /* returns an array of standard text and bindings, binding texts are later converted to bind objects               EXAMPLE::                string: "Hello {{name}}, {{greeting}}"                return: ["Hello ", "{{name}}", ", ", "{{greeting}}"]            */            function splitText(s) {                /* splits the string by _start and _end: ["Hello ","{{","name","}}",", ","{{","greeting","}}"] */                return s.split(new RegExp('(' + _start.split('').join('\\') + ')(.*?)(' + _end.split('').join('\\') + ')', 'g'))                    /* remaps values to have the _start and _end brackets: ["Hello ","{{","{{name}}","}}",", ","{{","{{greeting}}","}}"]*/                    .map(function(v, i, arr) {                        return ((arr[(i - 1)] === _start) ? (_start + v + _end) : v);                    })                    /* filter out single _start and _end entries: ["Hello ","{{name}}",", ","{{greeting}}"]*/                    .filter(function(v, i, arr) {                        return (v.length !== 0 && v !== _start && v !== _end && v.length !== 0);                    });            }            /* returns an array of standard bind names               EXAMPLE::                splitText: ["Hello ", "{{name}}", ", ", "{{greeting}}"]                return: ["name","greeting"]            */            function splitBindNames(splitTexts) {                /* filter out all non bind strings: ["{{name}}","{{greeting}}"]*/                return splitTexts.filter(function(v) {                        return (v.indexOf(_start) !== -1 && v.indexOf(_end) !== -1);                    })                    /* modify string to standard key names: ["name","greeting"]*/                    .map(function(v) {                        return splitKey(v);                    });            }            /* takes a bind and returns just the name/key               EXAMPLE::                string: "{{name | toUpperCase}}"                return: "name"            */            function splitKey(b) {                /* removes _start and _end from the string: "name | toUpperCase" */                return b.replace(new RegExp('[' + _start + _end + ']', 'g'), '')                    /* removes pipe and all that follows: "name "*/                    .replace(new RegExp('\\' + _pipe.split('').join('\\') + '(.*)'), '')                    /* removes any remaining spaces: "name" */                    .replace(/\s/g, '');            }            /* takes a bind and returns array of the filter names               EXAMPLE::                string: "{{name | toUpperCase, duplicate}}"                return: ["toUpperCase","duplicate"]            */            function splitFilters(b) {                if (b.indexOf(_pipe) !== -1) {                    /* remove _end characters from string: "{{name | toUpperCase, duplicate"  */                    return b.replace(new RegExp('[' + _end + ']', 'g'), '')                        /* removes everything before the _pipe characters: " toUpperCase, duplicate"*/                        .replace(new RegExp('(.*?)(\\' + _pipe.split('').join('\\') + ')'), '')                        /* removes all spaces "toUpperCase,duplicate"*/                        .replace(/\s/g, '')                        /* splits into array nased on ',': ["toUpperCase","duplicate"] */                        .split(',');                }                return [];            }            /* takes a for bind and returns array of key and component               EXAMPLE::                string: "{{for items loop listitem | hasName}}"                return: ["items","listitem"]            */            function splitFor(b) {                if (b.indexOf('for') !== -1) {                    /* removes _start and _end characters: "for items loop listitem | hasName" */                    return b.replace(new RegExp('[' + _start + _end + ']', 'g'), '')                        /* removes pipe and all text after it: "for items loop listitem "*/                        .replace(new RegExp('\\' + '|'.split('').join('\\') + '(.*)'), '')                        /* removes all empty spaces:  "foritemslooplistitem"*/                        .replace(/\s/g, '')                        /* splits the string removing 'for' and 'loop' leaving only key and component in an array: ["items","listitem"]*/                        .split(/for(.*?)loop/)                        /* in case any trailing empty strings are in array */                        .filter(function(v) {                            return v.length !== 0;                        });                }                return [];            }            /* returns a descriptor object */            function setDescriptor(value, writable, redefinable) {                return {                    value: value,                    writable: !!writable,                    enumerable: false,                    configurable: !!redefinable                }            }            function setBindDescriptor(get, set, enumerable, redefinable) {                return {                    get: get,                    set: set,                    enumerable: !!enumerable,                    configurable: !!redefinable                }            }            /* standard event object, allows stopPropagation, preventDefault, event type, and passed data */            function eventObject(type, data) {                this.preventDefault = function() {                    this._preventDefault = true;                }                this.stopPropagation = function() {                    this._stopPropogation = true;                }                this.type = type;                this.data = data;            }            /* runs the appropriate bus event */            function onEvent(key, eventObject) {                var _listeners = _events[key];                for (var x = 0, len = _listeners.length; x < len; x++) {                    _listeners[x](eventObject);                    /* if stopPropogation() method was called this stops all future listeners */                    if (!eventObject._stopPropogation) break;                }                return eventObject._preventDefault;            }            /* Library based methods for use globally among all components */            /* Globalized Event Listeners */            /* adds an event listener with the appropriate key */            function addEventListener(key, func) {                if (_events[key] !== undefined) {                    _events[key].push(func);                } else {                    console.error("Class: KonnektMP Method: 'addEventListener', No event exists with the name %o", key);                }                return this;            }            /* removes event listener, dependent on key and function being the same */            function removeEventListener(key, func) {                if (_events[key] !== undefined) {                    for (var x = 0, len = _events[key].length; x < len; x++) {                        if (_events[key][x].toString() === func.toString()) {                            _events[key].splice(x, 1);                        }                    }                } else {                    console.error("Class: KonnektMP Method: 'removeEventListener', No event exists with the name %o", key);                }                return this;            }            /* filters out names of unregistered elements from a template string */            function getUnknown(template) {                /* run regex match on all </end tags> */                var matched = template.match(_reNodes)                    .map(function(k) {                        /* remove '</' and '>' chars from string to leave just the name of the node */                        return k.replace(/[<\/>]/g, "");                    });                matched.filter(function(k, i) {                    /* filter out default elements and duplicates as well as components that are already registered */                    return ((document.createElement(k) instanceof HTMLUnknownElement) && (matched.indexOf(k, (i + 1)) === -1) && _templates[k] === undefined);                });                /* if there are unregistered components run global event for registration */                if (matched.length !== 0) onEvent('unknown', new Event('unknown', matched));                return matched;            }            /* checks if a component name has been defined */            function isRegistered(name) {                return (_templates[name] !== undefined);            }            /* registers template to a given name and fires unregistered components event if any are found */            function register(name, template) {                if (_templates[name] === undefined) {                    _templates[name] = template;                    /* unregistered components can be loaded via globalized listener on registration */                    getUnknown(template);                } else {                    console.error("Class: KonnektMP Method: 'register', A template by the name %o already exists", name);                }                return this;            }            /* searched start characters for looking for binds */            function start(v) {                if (v === undefined) return _start;                _start = (typeof v === 'string' ? v : _start);                return this;            }            /* searched end characters for looking for binds */            function end(v) {                if (v === undefined) return _end;                _end = (typeof v === 'string' ? v : _end);                return this;            }            /* searched pipe characters for looking for bind settings inside the bind */            function pipe(v) {                if (v === undefined) return _pipe;                _pipe = (typeof v === 'string' ? v : _pipe);                return this;            }            /* Assign as non changeable properties to main method for exporting */            Object.defineProperties(KonnektMP, {                start: setDescriptor(start),                end: setDescriptor(end),                pipe: setDescriptor(pipe),                getUnknown: setDescriptor(getUnknown),                isRegistered: setDescriptor(isRegistered),                register: setDescriptor(register),                addEventListener: setDescriptor(addEventListener),                removeEventListener: setDescriptor(removeEventListener)            });            /* Stop All HTML and setAttribute updates */            return KonnektMP;        }        return CreateKonnektMP;    }(CreateKB));    var CreateKonnekt = (function(CreateData, CreateLoader, CreateMapping, CreateHashRouting) {        function CreateKonnekt() {            if (!window.K_Components) window.K_Components = {};            /* main loader for loading files */            var _Loader = CreateLoader().onLoad(onComponentLoad),                /* Our mixed observable data library */                _mixed = CreateData(),                /* mapping library, for mapping new component: new _mapper(componentNode) */                _mapper = CreateMapping(),                /* routes components based on the current url hash, config.base sets the default route of '/' */                _hashrouter = CreateHashRouting()                .base((config !== undefined && config.base !== undefined ? config.base : 'default'))                .watch(true)                .onChange(function(name) {                    Konnekt(document.querySelector(name));                }),                /* this is a main model, data sets will be stored here for sharing between components and other libraries through this.store = true attribute */                _model = _mixed({}, "Model"),                /* the current loaded viewmodels */                _viewmodels = {},                /* this will be used later for current loaded cms components */                _cms = {},                /* url query attached to web addres: ?env=dev etc */                _query = getQuery(),                /* important ignore list for when creating a viewmodel, these attributes are not used for binding */                _ignoreList = ['id', 'filters', 'class', 'sessionStorage', 'localStorage', 'store', 'component', 'multiple'],                /* used for onload events, when a component has not been loaded from the server a request for load is made and the current script is placed in the waitlist until it has been loaded from the server to continue operation */                _waitList = {},                _baserouter;            /* This method will Create page, Create Viewmodel, attach binds, check children, load files, rinse, repeat */            function Konnekt(node, params, predt, postdt) {                /* name of the component */                var __name = node.tagName.toLowerCase(),                    /* the mapped binds */                    __mappedAttrs,                    /* we can get a list of all possibe events from the HTMLElement prototype */                    __events = Object.keys(HTMLElement.prototype)                    .filter(function(prop) {                        /* we filter for 'on' properties as these are all events */                        return (prop.indexOf('on') === 0);                    }),                    /* Pre -- all about built in data this will be allocated later to seperate file */                    /* Note** we may need to take another look at this as mixed pointers are being double processed */                    pre = {},                    /* post all about post set data and pointers */                    /* Note** we may need to take another look at this as mixed pointers are being double processed */                    post = {};                /* params are extra information passed to the viewmodel constructor, example: componentNode */                if (params === undefined) params = [];                if (predt) passKeys(predt, pre);                Object.defineProperty(pre, 'local', setDescriptor(pre.local || (__name + "-" + Date.now()), true, false, true));                /* base core filters usable in all components */                Object.defineProperty(pre, 'filters', setDescriptor(pre.filters || {}, false, false, true));                if (typeof pre.onFinish !== 'function') pre.onFinish = function() {};                Object.defineProperty(pre, 'onFinish', setDescriptor(pre.onFinish, true, false, true));                /* whether to attempt to store data in sessionStorage */                if (typeof pre.sessionStorage === 'string') pre.sessionStorage = (pre.sessionStorage === 'true');                Object.defineProperty(pre, 'sessionStorage', setDescriptor((pre.sessionStorage !== undefined ? pre.sessionStorage : false), true, false, true));                /* whether to attempt to store data in localStorage */                if (typeof pre.localStorage === 'string') pre.localStorage = (pre.localStorage === 'true');                Object.defineProperty(pre, 'localStorage', setDescriptor((pre.localStorage !== undefined ? pre.localStorage : false), true, false, true));                /* whether to attempt to store data in the model */                if (typeof pre.store === 'string') pre.store = (pre.store === 'true');                Object.defineProperty(pre, 'store', setDescriptor((pre.store !== undefined ? pre.store : false), true, false, true));                /* if this component can have children components of the same type, to prevent recursion */                if (typeof pre.multiple === 'string') pre.multiple = (pre.multiple === 'true');                Object.defineProperty(pre, 'multiple', setDescriptor((pre.multiple !== undefined ? pre.multiple : false), true, false, true));                if (postdt) passKeys(postdt, post);                /* if the component contained any innerHTML this gets placed into a post bindable */                post.innerHTML = Array.prototype.slice.call(node.childNodes);                for (var x = 0, len = node.attributes.length; x < len; x++) {                    post[node.attributes[x].name] = node.attributes[x].value;                }                /* add all events to post for binding to inner component */                for (var x = 0, len = __events.length; x < len; x++) {                    if (node[__events[x]]) post[__events[x]] = node[__events[x]];                }                /* add any data attached to k_post  property */                if (node.k_post) passKeys(node.k_post, post);                /* The main viewmodel constructor */                function createViewmodel(name, component, params, pre, post) {                    /* creates blank observable data set */                    var obsv = _mixed({}, name);                    /* if there are any prototypes on this component they are added to the Data sets prototype */                    for (var x = 0, keys = Object.keys(component.prototype), len = keys.length; x < len; x++) {                        obsv.__proto__[keys[x]] = component.prototype[keys[x]];                    }                    /* Attach Pre properties, or pre designed attachments for every Data set */                    for (var x = 0, keys = Object.keys(pre), len = keys.length; x < len; x++) {                        if (_ignoreList.indexOf(keys[x]) !== -1) {                            Object.defineProperty(obsv, keys[x], setDescriptor(pre[keys[x]], (keys[x] !== 'filters')));                        } else {                            if (pre.pointers) {                                if (pre.pointers[keys[x]] === undefined) obsv.set(keys[x], pre[keys[x]]);                            } else {                                obsv.set(keys[x], pre[keys[x]]);                            }                        }                    }                    if (pre.pointers) {                        if (!obsv.pointers) Object.defineProperty(obsv, 'pointers', setDescriptor({}, false, true));                        for (var x = 0, keys = Object.keys(pre.pointers), len = keys.length; x < len; x++) {                            obsv.pointers[keys[x]] = pre.pointers[keys[x]];                            obsv.addPointer(obsv.pointers[keys[x]].point, obsv.pointers[keys[x]].key, keys[x]);                        }                    }                    /* we then apply the component constructor to the data set in order to add the 'this' properties from it and pass in the params */                    component.apply(obsv, params);                    /* Post attachments, overwritables, for data or pointers */                    for (var x = 0, keys = Object.keys(post), len = keys.length; x < len; x++) {                        if (_ignoreList.indexOf(keys[x]) !== -1) {                            Object.defineProperty(obsv, keys[x], setDescriptor(post[keys[x]], (keys[x] !== 'filters')));                        } else {                            if (post.pointers) {                                if (post.pointers[keys[x]] === undefined) obsv.set(keys[x], post[keys[x]]);                            } else {                                obsv.set(keys[x], post[keys[x]]);                            }                        }                    }                    /* post pointers */                    if (post.pointers) {                        if (!obsv.pointers) Object.defineProperty(obsv, 'pointers', setDescriptor({}, false, true));                        for (var x = 0, keys = Object.keys(post.pointers), len = keys.length; x < len; x++) {                            obsv.pointers[keys[x]] = post.pointers[keys[x]];                            obsv.addPointer(obsv.pointers[keys[x]].point, obsv.pointers[keys[x]].key, keys[x]);                        }                    }                    /* map filters as binded to vm */                    for (var x = 0, keys = Object.keys(obsv.filters), len = keys.length; x < len; x++) {                        obsv.filters[keys[x]] = obsv.filters[keys[x]].bind(obsv);                    }                    /* Apply session storage if set, this allows for storing this vm in session storage, only those values that are enumerable */                    if (obsv.sessionStorage) {                        var storage = sessionStorage.getItem((obsv.id || name));                        /* load storage into the data set if it is set */                        if (storage) {                            storage = JSON.parse(storage);                            for (var x = 0, keys = Object.keys(storage), len = keys.length; x < len; x++) {                                obsv.set(keys[x], storage[keys[x]]);                            }                        }                        /* set the storage object with the defaults */                        else {                            sessionStorage.setItem((obsv.id || name), obsv.stringify());                        }                        /* if any data updates then the storage will be updated along with it */                        obsv.addChildDataUpdateListener('*', function() {                            sessionStorage.setItem((obsv.id || name), obsv.stringify());                        });                    }                    /* Apply local storage if set, similiar to session Storage except this persists even after browser is closed */                    if (obsv.localStorage) {                        var storage = localStorage.getItem((obsv.id || name));                        /* load storage into the data set if it is set */                        if (storage) {                            storage = JSON.parse(storage);                            for (var x = 0, keys = Object.keys(storage), len = keys.length; x < len; x++) {                                obsv.set(keys[x], storage[keys[x]]);                            }                        }                        /* set the storage object with the defaults */                        else {                            localStorage.setItem((obsv.id || name), obsv.stringify());                        }                        /* if any data updates then the storage will be updated along with it */                        obsv.addChildDataUpdateListener('*', function() {                            localStorage.setItem((obsv.id || name), obsv.stringify());                        });                    }                    if (obsv.store) {                        /* adds a pointer in model to this viewmodel, look into using id as an id from component: <test id="storeid"></test> */                        _model.set((obsv.id || name), obsv);                    }                    return obsv;                }                /* in charge of connecting the viewmodel up to the allocated maps */                function mapTargets(target, mappedAttrs, vm) {                    /* attaches viewmodel to wrapper */                    target.kb_viewmodel = vm;                    mappedAttrs.wrapper.innerHTML = __mappedAttrs.template.replace(new RegExp('(' + _mapper.start() + 'local' + _mapper.end() + ')', 'g'), vm.local);                    /* map nodes with their bindings */                    var maps = mappedAttrs.maps = mappedAttrs.map(mappedAttrs.wrapper);                    mappedAttrs.wrapper.kb_maps = maps;                    /* loops through maps: {key:[map,map],key2:[map,map]} */                    Object.keys(maps).forEach(function(key) {                        maps[key].forEach(function(map) {                            switch (map.type) {                                case 'for':                                    /* connects viewmodel and then loop creates components for converting and deletes original map*/                                    map.connect(vm);                                    if (!_mapper.isRegistered(map.component)) {                                        Konnekt.loadWaitList(map.component, function(n, c) {                                            map.loop(function(node) {                                                Konnekt(node);                                            });                                        });                                        if (!Konnekt.loadWaitList(map.component).loading) {                                            Konnekt.loadWaitList(map.component).loading = true;                                            _Loader(map.component);                                        }                                    } else {                                        map.loop(function(node) {                                            Konnekt(node);                                        });                                    }                                    break;                                case 'component':                                    /* connects viewmodel updates value and then deletes map as it won't be used again */                                    map.connect(vm).unsync();                                    break;                                default:                                    /* standard data connection and value set */                                    map.connect(vm);                                    break;                            }                        })                    });                    mappedAttrs.wrapper.kb_viewmodel.onFinish.call(mappedAttrs.wrapper.kb_viewmodel, mappedAttrs.wrapper);                }                function getInnerComponents(node) {                    var nodes = node.querySelectorAll('*');                    for (var x = 0, len = nodes.length; x < len; x++) {                        if (nodes[x] instanceof HTMLUnknownElement) {                            Konnekt(nodes[x]);                        }                    }                }                function init(name, node) {                    /* Create node template and map the inner nodes of the template */                    __mappedAttrs = new _mapper(node, true);                    /* define component tree for multiples later */                    Object.defineProperty(__mappedAttrs.wrapper, '__kbcomponenttree', setDescriptor(node.kb_mapper ? node.kb_mapper.__kbcomponenttree.slice() : []));                    /* replace original node with new templated node */                    node.parentElement.replaceChild(__mappedAttrs.fragment, node);                    /* add new nodes to params for passing to viewmodels */                    params.unshift(__mappedAttrs.wrapper);                    /* map targets connects the viewmodel data to the dom and vice versa */                    mapTargets(__mappedAttrs.wrapper, __mappedAttrs, createViewmodel(name, _viewmodels[name], params, pre, post));                    /* check for multiples */                    if (__mappedAttrs.wrapper.__kbcomponenttree.indexOf(name) === -1 || __mappedAttrs.wrapper.kb_viewmodel.multiple) {                        /* add to component tree and search for inner unkown components */                        __mappedAttrs.wrapper.__kbcomponenttree.push(name);                        __mappedAttrs.wrapper.classList.add(__mappedAttrs.wrapper.kb_viewmodel.local);                        getInnerComponents(__mappedAttrs.wrapper);                    } else {                        console.error("Warning!! You are attempting to make a recursive component %o, recursive components can lead to memory stack overflows unless properly handled, Please check your components html for use of this component, if You want this to be a recursive component please set `this.multiple = true;`", name);                        console.error("Recursive Component %o on %o", __mappedAttrs.wrapper, __mappedAttrs.wrapper.parentElement);                        __mappedAttrs.wrapper.parentElement.removeChild(__mappedAttrs.wrapper);                    }                }                if (!_mapper.isRegistered(__name)) {                    Konnekt.loadWaitList(__name, function(n, c) {                        init(__name, node);                    });                    if (!Konnekt.loadWaitList(__name).loading) {                        Konnekt.loadWaitList(__name).loading = true;                        _Loader(__name);                    }                } else {                    init(__name, node);                }            }            function passKeys(obj, obj2) {                var keys = Object.keys(obj);                if (!obj2.pointers) Object.defineProperty(obj2, 'pointers', {                    value: {},                    writable: true,                    enumerable: false,                    configurable: true                });                for (var x = 0, len = keys.length; x < len; x++) {                    if (_mixed.prototype.isObservable(obj, keys[x])) {                        obj2.pointers[keys[x]] = {                            key: obj.__kbscopeString.split('.').pop(),                            point: obj.__kbImmediateParent                        };                    } else if (_mixed.prototype.isMixed(obj[keys[x]])) {                        obj2.pointers[keys[x]] = {                            key: obj[keys[x]].__kbImmediateParent.__kbscopeString.split('.').pop(),                            point: obj[keys[x]].__kbImmediateParent.__kbImmediateParent                        };                    } else {                        if (_mixed.prototype.isObject(obj[keys[x]])) {                            for (var i = 0, keysI = Object.keys(obj[keys[x]]), lenI = keysI.length; i < len; i++) {                                obj2[keys[x]][keysI[i]] = obj[keys[x]][keysI[i]];                            }                        } else if (_mixed.prototype.isArray(obj[keys[x]])) {                            for (var i = 0, lenI = obj[keys[x]].length; i < len; i++) {                                obj2[keys[x]][i] = obj[keys[x]][i];                            }                        } else {                            obj2[keys[x]] = obj[keys[x]];                        }                    }                }            }            function setDescriptor(value, writable, redefinable, enumerable) {                return {                    value: value,                    writable: !!writable,                    enumerable: !!enumerable,                    configurable: !!redefinable                }            }            function getQuery() {                return window.location.search.replace('?', '')                    .split('&')                    .filter(function(v) {                        return (v.length !== 0);                    })                    .reduce(function(o, v) {                        o[v.split('=')[0]] = v.split('=')[1];                        return o;                    }, {});            }            function onComponentLoad(name, component) {                var template = "<style>" + unescape(component.prototype.k_css) + "</style>" + unescape(component.prototype.k_html);                Konnekt.register(name, component, template, component.prototype.cms);                /*_mapper.getUnkowns(template).forEach(function(u){                  _Loader(u);                });*/                Konnekt.loadWaitList(name).forEach(function(onload) {                    onload(name, component);                });                Konnekt.loadWaitList(name, 'clear');            }            /* Registers name to a component */            Konnekt.register = function(name, vm, template, cms) {                _mapper.register(name, template);                _viewmodels[name] = vm;                if (cms) _cms[name] = cms;                return Konnekt;            }            /* register for a component to load and be registered */            Konnekt.loadWaitList = function(name, v) {                if (typeof v === 'undefined' && name) return _waitList[name];                if (name) {                    if (_waitList[name] === undefined || v === 'clear') {                        var loaded = (_waitList[name] === undefined ? false : !!_waitList[name].loading);                        _waitList[name] = [];                        _waitList[name].loading = loaded;                    }                    if (typeof v === 'function') _waitList[name].push(v);                }                return Konnekt;            }            Konnekt.localRouting = function(isRouting) {                if (isRouting) {                    _baserouter = Node.prototype.appendChild;                    Node.prototype.appendChild = function(node) {                        if (node.nodeName.toLowerCase() === 'script') {                            node.src = node.src.substring(0, (node.src.indexOf('?') !== -1 ? node.src.indexOf('?') : node.src.length));                            var match = node.src.match(/(.*?component\/)/);                            if (match) {                                if (!_query.env) _query.env = 'prod';                                if (_query.env === 'dev') _query.env = 'qa';                                var name = node.src.replace(match[0], '').replace(/[\/\s]/g, '');                                node.src = '/components/' + name + '/build/' + _query.env + '/' + name + (!_query.debug || _query.env === 'prod' ? '.min' : '') + '.js';                                arguments[0] = node;                            }                        }                        return _baserouter.apply(this, arguments);                    }                } else {                    if (_baserouter) {                        Node.prototype.appendChild = _baserouter;                        _baserouter = null;                    }                }                return Konnekt;            }            Konnekt.hashRouting = function(isHashed) {                if (isHashed) {                    _hashrouter(window.location.hash.replace('#', ''));                }            }            return Konnekt;        }        return CreateKonnekt;    }(CreateKonnektDT, CreateKonnektL, CreateKonnektMP, CreateKonnektRTF));    if ((typeof window !== 'undefined') && (typeof window.define !== 'undefined') && (typeof window.require !== 'undefined')) {        define([], function() {            return CreateKonnekt;        });    } else if ((typeof module !== 'undefined')) {        module.exports = CreateKonnekt;    }    return CreateKonnekt;}())