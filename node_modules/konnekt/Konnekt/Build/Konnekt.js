var Konnekt = (function() {    var CreateKonnektDT = (function() {        function CreateKonnektDT(data, name, parent, scope) {            var _events = {                    "set": [],                    "postset": [],                    "create": [],                    "postcreate": [],                    "delete": [],                    "postdelete": [],                    "splice": [],                    "postsplice": [],                    "push": [],                    "postpush": [],                    "pop": [],                    "postpop": [],                    "shift": [],                    "postshift": [],                    "unshift": [],                    "postunshift": [],                    "fill": [],                    "postfill": [],                    "reverse": [],                    "postreverse": [],                    "sort": [],                    "postsort": [],                    "addlistener": [],                    "postaddlistener": [],                    "removelistener": [],                    "postremovelistener": [],                    "addchildlistener": [],                    "postaddchildlistener": [],                    "removechildlistener": [],                    "postremovechildlistener": []                },                _ignoreList = ['__proto__', '_stopChange'],                _loopEvents = function(events, e) {                    if (!e._stopPropogration && events) {                        for (var x = 0, len = events.length; x !== len; x++) {                            events[x](e);                            if (e._stopPropogration) break;                        }                    }                },                _onevent = function(e) {                    if (e.listener) {                        var _local = e.local[e.listener],                            _child = e.local[(e.listener.replace('__kb', '__kbparent'))];                        /* Local */                        if (isObject.call(_local)) {                            _loopEvents(_local[e.key], e);                            _loopEvents(_local['*'], e);                        } else {                            _loopEvents(_local, e);                        }                        /* Child */                        if (isObject.call(_child)) {                            _loopEvents(_child[e.key], e);                            _loopEvents(_child['*'], e);                        } else {                            _loopEvents(_child, e);                        }                    }                    _loopEvents(e.local.__kbref.__kbevents[e.type], e);                    return e._preventDefault;                },                ArrSort = Array.prototype.sort,                ArrSlice = Array.prototype.slice,                typeChecker;            if (!Object.prototype._toString) Object.prototype._toString = Object.prototype.toString;            if (!Object._keys) Object._keys = Object.keys;            Object.prototype.toString = function() {                if (this instanceof Mixed) return "[object Mixed]";                return Object.prototype._toString.apply(this, arguments);            }            Object.keys = function(v, type) {                return Object._keys(v)                    .filter(function(k) {                        return ((!type) || ((type === 'object' || type === 'o')) ? (isNaN(parseInt(k, 10))) : (type === 'all' ? true : (!isNaN(parseInt(k, 10)))));                    });            };            typeChecker = ({}).toString;            /* The Main constructor */            function Mixed(data, name, parent, scope) {                data = (data === undefined ? {} : data);                /* Object prototype extensions chained down to the function */                ;                var KonnektDT = {};                var prox = (!!window.Proxy ? new Proxy(KonnektDT, {                        set: proxySet,                        deleteProperty: proxyDelete                    }) : KonnektDT),                    keys = Object.keys(data, 'all');                Object.defineProperties(KonnektDT, {                    __kbname: setDescriptor((typeof name === 'string' ? name : "default"), true, true),                    __kbref: setDescriptor((parent ? (parent.__kbref || parent) : prox), true, true),                    __kbscopeString: setDescriptor((scope || ""), true, true),                    __kbImmediateParent: setDescriptor((parent || null), true, true),                    __kbsubscribers: setDescriptor({}),                    __kbparentsubscribers: setDescriptor({}),                    __kblisteners: setDescriptor({}),                    __kbupdatelisteners: setDescriptor({}),                    __kbparentlisteners: setDescriptor({}),                    __kbparentupdatelisteners: setDescriptor({}),                    __kbcreatelisteners: setDescriptor([]),                    __kbdeletelisteners: setDescriptor([]),                    __kbparentcreatelisteners: setDescriptor([]),                    __kbparentdeletelisteners: setDescriptor([]),                    __kbmethodlisteners: setDescriptor([]),                    __kbmethodupdatelisteners: setDescriptor([]),                    __kbpointers: setDescriptor({}),                    __kbevents: setDescriptor(_events),                    __kbsetindex: setDescriptor(0, true),                    __kbproto: setDescriptor({}),                    length: setDescriptor(0, true),                    __kbnonproxy: setDescriptor(KonnektDT, false, true),                    __kbproxy: setDescriptor(prox, false, true),                    _stopChange: setDescriptor(false, true)                });                KonnektDT.__proto__ = Mixed.prototype;                for (var x = 0, len = keys.length; x < len; x++) {                    prox.set(keys[x], data[keys[x]]);                }                /* clear listeners */                KonnektDT.__kbevents.addlistener = [];                KonnektDT.__kbevents.removelistener = [];                KonnektDT.addActionListener('addlistener', function(e) {                        if (typeof e.arguments[0] === 'string' && e.local.__kbpointers[e.arguments[0]] !== undefined) {                            var localPointer = e.local.__kbpointers[e.arguments[0]],                                localLayer = localPointer.point.getLayer(localPointer.keys);                            if (localLayer[e.arguments[0]] !== undefined) {                                localLayer[e.arguments[2]](e.arguments[0], e.arguments[1]);                            } else if (localLayer[localPointer.keys.split('.').pop()] !== undefined) {                                localLayer[e.arguments[2]](localPointer.keys.split('.').pop(), e.arguments[1]);                            }                        }                    })                    .addActionListener('removelistener', function(e) {                        if (typeof e.arguments[0] === 'string' && e.local.__kbpointers[e.arguments[0]] !== undefined) {                            var localPointer = e.local.__kbpointers[e.arguments[0]],                                localLayer = localPointer.point.getLayer(localPointer.keys);                            if (localLayer[e.arguments[0]] !== undefined) {                                localLayer[e.arguments[2]](e.arguments[0], e.arguments[1]);                            } else if (localLayer[localPointerkeys.split('.').pop()] !== undefined) {                                localLayer[e.arguments[2]](localPointer.keys.split('.').pop(), e.arguments[1]);                            }                        }                    })                return prox;            }            /* Helper methods and the main proxy Methods */            function eventObject(obj, key, type, value, oldValue, args, listener, stopChange) {                this.stopPropogation = function() {                    this._stopPropogration = true;                }                this.preventDefault = function() {                    this._preventDefault = true;                }                this.local = obj;                this.key = key;                this.arguments = args;                this.event = type;                this.type = type;                this.listener = listener;                this.name = obj.__kbname;                this.root = obj.__kbref;                this.scope = obj.__kbscopeString;                this.parent = obj.__kbImmediateParent;                this.value = value;                this.oldValue = oldValue;                this.stopChange = stopChange;            }            function setDescriptor(value, writable, redefinable, enumerable) {                return {                    value: value,                    writable: !!writable,                    enumerable: !!enumerable,                    configurable: !!redefinable                }            }            function setCustomDescriptor(func, writable, redefinable) {                return {                    get: function() {                        return func.call(this);                    },                    set: function(v) {                        if (!!writable) func = v;                    },                    enumerable: false,                    configurable: !!redefinable                }            }            function setBindDescriptor(key, value) {                var _value = value,                    _oldValue = value,                    _key = key,                    _set = function(v, e) {                        _oldValue = _value;                        _value = v;                        if (!e.stopChange) {                            e.listener = '__kbupdatelisteners';                            e.type = 'postset';                            _onevent(e);                        }                    };                return {                    get: function() {                        return _value;                    },                    set: function(v) {                        var e = new eventObject(this, _key, 'set', v, _value, arguments, '__kblisteners', this._stopChange);                        if (_onevent(e) !== true) {                            _set(v, e);                            this.callSubscribers(this.__kbref, this, _key, _value, _oldValue, this._stopChange);                        }                        this._stopChange = false;                    },                    configurable: true,                    enumerable: true                }            }            function setPointer() {                var points = Array.prototype.slice.call(arguments),                    obj = points.shift();                return {                    get: function() {                        return points.reduce(function(o, p) {                            return o[p];                        }, obj);                    },                    set: function(v) {                        var local = points.slice(0, (points.length - 1)).reduce(function(o, p) {                            return o[p];                        }, obj);                        (this._stopChange ? local.stopChange() : local)[points[(points.length - 1)]] = v;                        this._stopChange = false;                    },                    enumerable: true,                    configurable: true                }            }            function parseParentListenersToNewObjects(mixed, target) {                var listeners = [{                            listener: '__kbparentlisteners',                            action: 'addChildListener'                        },                        {                            listener: '__kbparentupdatelisteners',                            action: 'addChildUpdateListener'                        },                        {                            listener: '__kbparentcreatelisteners',                            action: 'addChildCreateListener'                        },                        {                            listener: '__kbparentdeletelisteners',                            action: 'addChildDeleteListener'                        }                    ],                    keys = [],                    _currListener;                for (var x = 0, len = listeners.length; x < len; x++) {                    _currListener = mixed[listeners[x].listener];                    if (isObject.call(_currListener)) {                        keys = Object.keys(_currListener);                        for (var i = 0, lenI = keys.length; i < lenI; i++) {                            for (var z = 0, lenZ = _currListener[keys[i]].length; z < lenZ; z++) {                                target[listeners[x].method](keys[i], _currListener[keys[i]][z]);                            }                        }                    } else {                        for (var i = 0, lenI = _currListener.length; i < lenI; i++) {                            target[listeners[x].method](_currListener[i]);                        }                    }                }            }            /* needs looked into if even necessary */            function parsePointerEvents(target, key) {                var events = [{                            listener: '__kblisteners',                            method: 'addDataListener'                        },                        {                            listener: '__kbupdatelisteners',                            method: 'addDataUpdateListener'                        }                    ],                    keys = [],                    _currListener;                if (target[key] && target[key].__kbImmediateParent) {                    for (var x = 0, len = events.length; x < len; x++) {                        _currListener = target[events[x].listener];                        keys = Object.keys(_currListener);                        for (var i = 0, lenI = keys.length; i < lenI; i++) {                            if (key === keys[x]) {                                for (var z = 0, lenZ = _currListener[keys[x]].length; z < lenZ; z++) {                                    if (target[key].__kbImmediateParent[events[x].listener][key] === undefined) target[key].__kbImmediateParent[events[x].listener][key] = [];                                    target[key].__kbImmediateParent[events[x].listener][key].push(_currListener[keys[x]][z]);                                }                            }                        }                    }                }                parseParentListenersToNewObjects(target, target[key]);            }            /* create check if value is just undefined but descriptor is set */            function proxySet(target, key, value) {                if (!isObservable(target, key) && key !== 'length' && key !== '__kbsetindex') {                    target.set(key, value);                } else {                    if (key === 'length') {                        if (value > target.length && target[(value - 1)] !== undefined) {                            target.length = value;                        } else if (value < target.length) {                            for (var x = value, len = (target.length); x < len; x++) {                                if (target[x]) delete target[x];                            }                            target.length = value;                        }                    } else {                        target[key] = value;                    }                    return true;                }            }            /* Need to handle removing parentListeners prior to removal */            function proxyDelete(target, key) {                target.del(key);                return true;            }            function handleNewProperty(target, key, value) {                var _layer = this.__kbnonproxy,                    _isMixed = isMixed(value),                    _isObject = isObject(value),                    _isArray = isArray(value);                if (_isMixed && value.__kbname !== target.__kbname) {                    if (value.__kbname === 'default') {                        target.merge(value, key);                    } else if (!target.__kbpointers[key]) {                        target.addPointer(value, key);                    }                } else {                    var e = new eventObject(this, key, 'create', value, undefined, [], '__kbcreatelisteners', this._stopChange),                        onEvent = _onevent(e),                        keyNum = parseInt(key, 10);                    if (onEvent !== true) {                        if ((_isObject || _isArray) && Object.keys(value, 'all').length !== 0) {                            handleNewProperty.call(this, target, key, {});                            for (var x = 0, keys = Object.keys(value, 'all'), len = keys.length; x < len; x++) {                                handleNewProperty.call(this[key], target[key], keys[x], value[keys[x]]);                            }                        } else {                            if (_isObject || _isArray) {                                value = new Mixed(value, target.__kbname, target, target.__kbscopeString + (target.__kbscopeString.length !== 0 ? "." : "") + key);                                parseParentListenersToNewObjects(target, value);                            }                            Object.defineProperty(target, key, setBindDescriptor(key, value));                            if (!isNaN(keyNum) && target.length <= keyNum) target.length = (keyNum + 1);                            e.listener = '__kbupdatelisteners';                            e.type = 'postcreate';                            _onevent(e);                        }                    }                }            }            /* replaces the use of using a proxy to run the parser through */            function recSet(obj, key, value, stopChange) {                var _isMixed = isMixed(value),                    _isObject = isObject(value),                    _isArray = isArray(value);                if (_isMixed && value.__kbname !== obj.__kbname) {                    if (value.__kbname === 'default') {                        obj.merge(value, key);                    } else if (!obj.__kbpointers[key]) {                        obj.addPointer(value, key);                    }                } else if (obj[key] === undefined) {                    if (_ignoreList.indexOf(key) === -1) {                        handleNewProperty.call(this, obj, key, value);                    } else {                        (!!stopChange ? obj.stopChange() : obj)[key] = value;                    }                } else {                    if (_isObject || _isArray) {                        for (var x = 0, keys = Object.keys(value, 'all'), len = keys.length; x < len; x++) {                            recSet.call(this[key], obj[key], keys[x], value[keys[x]], stopChange);                        }                    } else {                        (!!stopChange ? obj.stopChange() : obj)[key] = value;                    }                }            }            function ignoreCreate(name) {                if (_ignoreList.indexOf(name) === -1) _ignoreList.push(name);                return this;            }            /* REGION Object extensions */            function type(v) {                return typeChecker.call(v).replace(/(\[object\s|\])/g, '').toLowerCase();            }            function sizeof(v) {                var cache = [];                function recGet(obj) {                    var keys = Object.keys(obj, 'all'),                        count = 0,                        _curr = undefined;                    for (var x = 0, len = keys.length; x < len; x++) {                        _curr = obj[keys[x]];                        if (typeof _curr === 'object' && _curr !== undefined && _curr !== null) {                            if (cache.indexOf(_curr) === -1) {                                cache.push(_curr);                                count += recGet(_curr);                            }                        } else if (typeof _curr === 'string') {                            count += (_curr.length * 2);                        } else if (typeof _curr === 'number') {                            count += 8;                        } else if (typeof _curr === 'boolean') {                            count += 4;                        } else if (typeof _curr === 'function') {                            count += (_curr.toString().length * 2);                        }                        count += (keys[x].length * 2);                    }                    return count;                }                return recGet((v || this)) + " Bytes (Rough estimate)";            }            function isObject(v) {                return (type((v !== undefined ? v : this)) === 'object');            }            function isArray(v) {                return (type((v !== undefined ? v : this)) === 'array');            }            function isMixed(v) {                return (type((v !== undefined ? v : this)) === 'mixed');            }            function isObservable(obj, prop) {                prop = (typeof obj === 'string' ? obj : prop);                obj = (typeof obj === 'string' ? this : obj);                var desc = Object.getOwnPropertyDescriptor(obj, prop);                return (desc ? (desc.value === undefined) : false);            }            function stringify(v) {                var cache = [];                return JSON.stringify((v || this), function(key, value) {                    if (isArray(value) || isObject(value)) {                        if (cache.indexOf(value) !== -1) {                            return;                        }                        cache.push(value);                    }                    return value;                });            }            function getKeys(v, type) {                type = (typeof v === 'string' ? v : (!type ? 'object' : type));                v = (typeof v === 'string' || v === undefined ? this : v);                return Object.keys(v, type);            }            function getIndexes(v) {                v = (v !== undefined ? (typeof v === 'object' ? v : this[v]) : this);                var _ret = [];                for (var x = 0, len = v.length; x < len; x++) {                    if (v[x] !== undefined) _ret[_ret.length] = x;                }                return _ret            }            function keyCount() {                return this.getKeys('object').length;            }            function indexCount() {                return (this).length;            }            function count() {                return (this.keyCount + this.indexCount);            }            function parse(json, func) {                var layer = this.__kbnonproxy,                    /* This makes sure the selection is not inside a "" string as a value */                    /*                     notInString = '(?=(?:[^"]|"[^"]*")*$)',                    startObject = '\\{'+notInString,                    endObject = '\\}'+notInString,                    startKey1 = '\\{\\"',                    startKey2 = '\\,\\"'+notInString,                    startArr = '\\['+notInString,                    endArr = '\\]'+notInString,                    nextIndex = '\\,'+notInString,                    startValue = '\\"\\:',                    endValue = '\\"\\}',                    regEx = new RegExp('('+startKey1+'|'+startKey2+'|'+startArr+'|'+endArr+'|'+startValue+'|'+endValue+'|'+startObject+'|'+nextIndex+'|'+endObject+')'),                    */                    regEx = /({"|,"(?=(?:[^"]|"[^"]*")*$)|\[(?=(?:[^"]|"[^"]*")*$)|\](?=(?:[^"]|"[^"]*")*$)|":|"}|{(?=(?:[^"]|"[^"]*")*$)|,(?=(?:[^"]|"[^"]*")*$)|}(?=(?:[^"]|"[^"]*")*$))/;                split = json.split(regEx).filter(Boolean),                    UKeys = [],                    isKey = false,                    isValue = false,                    scope = '';                function parseValue(val) {                    var i = parseFloat(val, 10),                        b = (val === 'true'),                        l1 = val.indexOf('"'),                        l2 = val.lastIndexOf('"');                    if (!isNaN(i) && i.toString().length === val.length) {                        return i;                    } else if (b || val === 'false') {                        return b;                    } else {                        if (l1 === 0 && l2 !== 0) {                            val = val.substring(1, (val.length - 1));                        } else {                            val = val.substring(1, val.length);                        }                    }                    return val;                }                /* looking for: {" or ": ," }*/                for (var x = 1, len = split.length, currKey, prevKey, futureKey, UKey; x < len; x++) {                    currKey = split[x];                    prevKey = split[(x - 1)];                    futureKey = split[(x + 1)];                    UKey = UKeys[(UKeys.length - 1)];                    /* we have a new object */                    if ((prevKey === '":' && currKey === '{"') || (prevKey === '":' && currKey === '[')) {                        scope += (scope.length !== 0 ? '.' : '') + UKey;                        if (!layer[UKey]) layer.set(UKey, (func ? func(UKey, {}, scope, layer) : {}));                        layer = layer[UKey];                        UKeys.pop();                    }                    /* we have an array index */                    else if (prevKey === '[' || (prevKey === ',' && layer.length !== 0)) {                        if (currKey === '{' || currKey === '{"') {                            scope += (scope.length !== 0 ? '.' : '') + layer.__kbsetindex;                            if (typeof layer[layer.__kbsetindex] !== 'object') layer.set(layer.__kbsetindex, (func ? func(layer.length, {}, scope, layer) : {}));                            layer.__kbsetindex += 1;                            layer = layer[(layer.__kbsetindex - 1)];                        } else {                            layer.set(layer.__kbsetindex, (func ? func(layer.length, parseValue(currKey), scope, layer) : parseValue(currKey)));                            layer.__kbsetindex += 1;                        }                    }                    /* we have a value */                    else if (prevKey === '":') {                        layer.set(UKey, (func ? func(UKey, parseValue(currKey), scope, layer) : parseValue(currKey)));                        UKeys.pop();                    }                    /* we have a key */                    else if (prevKey === '{"' || (prevKey === ',' && futureKey === '":')) {                        UKeys[UKeys.length] = currKey.replace(/\"/g, '');                    }                    /* we go out of current object */                    else if ((prevKey === '}' || prevKey === ']') && currKey !== undefined) {                        scope = (scope.indexOf('.') !== -1 ? scope.substring(0, (scope.lastIndexOf('.') - 1)) : '');                        layer = layer.__kbImmediateParent;                    }                }                return this;            }            function parseReplace(json, obj) {                return parse.call((obj || this), json);            }            /* ENDREGION Object extensions */            /* REGION Object methods */            function add(key, value) {                set.call(this, key, value);                return this;            }            function set(key, value) {                if (typeof key === 'number') key = key.toString();                var _layer = (key.indexOf('.') !== -1 ? this.__kbnonproxy.setLayer(key) : this.__kbnonproxy);                if (key.indexOf('.') !== -1) key = key.split('.').pop();                var e = new eventObject(this, key, 'set', value, (this[key]), arguments, '__kbmethodlisteners'),                    onEvent = _onevent(e);                if (onEvent !== true) {                    recSet.call(this, _layer, key, value, this._stopChange);                    this.stopChange = undefined;                    e.type = 'postset';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this;            }            /* Always return Proxy if used `.get` and `.getlayer` both apply this rule */            function get(key) {                if (typeof key === 'number') key = key.toString();                var _layer = (key.indexOf('.') !== -1 ? this.getLayer(key) : this);                if (key.indexOf('.') !== -1) key = key.split('.').pop();                if (_layer) {                    return _layer[key];                } else {                    console.warn('Module: KonnektDT, Method: get, nothing exists on %o with the key %o', this, key);                }            }            function exists(key) {                var _layer = (key.indexOf('.') !== -1 ? this.__kbnonproxy.getLayer(key) : this.__kbnonproxy);                if (key.indexOf('.') !== -1) key = key.split('.').pop();                if (!_layer) return !!_layer;                return (_layer[key] !== undefined);            }            function addPrototype(key, value) {                var _layer = (key.indexOf('.') !== -1 ? this.__kbnonproxy.setLayer(key) : this.__kbnonproxy);                if (key.indexOf('.') !== -1) key = key.split('.').pop();                if (_layer[key] === undefined) {                    Object.defineProperty(_layer.__proto__, key, setDescriptor(value, true, true));                } else {                    console.error('Your attempting to add your prototype with the prop %O that already exists on %O', prop, _layer);                }                return this;            }            /* Handle listener sharing (done in addlistener Methods) */            function addPointer() {                var points = Array.prototype.slice.call(arguments),                    passobj = points.shift(),                    prop = (passobj.exists(points.join('.')) ? points[(points.length - 1)] : points.pop());                if (!(passobj instanceof Mixed)) passobj = new Mixed(passobj, passobj.__kbname);                var e = new eventObject(this, prop, 'create', passobj[prop], undefined, [], '__kbcreatelisteners', this._stopChange),                    _layer = this.__kbnonproxy;                e.root = passobj.__kbref.__kbproxy;                if (_onevent(e) !== true) {                    Object.defineProperty(_layer, prop, setPointer.apply(_layer, [passobj].concat(points)));                    _layer.__kbpointers[prop] = {                        keys: points.join('.'),                        point: passobj                    };                    parsePointerEvents(_layer, prop);                    e.listener = '__kbupdatelisteners';                    e.type = 'postcreate';                    _onevent(e);                }                return this;            }            /* handles all deleting */            function del(key, bypass) {                var _isNumber = (typeof key === 'number' || !isNaN(parseInt(key, 10)));                if (_isNumber) key = key.toString();                var _layer = (key.indexOf('.') !== -1 ? this.getLayer(key) : this),                    _localProp = key.split('.').pop();                if (!!_layer && _layer[_localProp] !== undefined) {                    if (_isNumber && _layer.length > parseInt(key, 10) && !bypass) {                        _layer = _layer.__kbnonproxy;                        _layer.splice(_localProp, 1);                    } else {                        var eM = new eventObject(_layer, key, 'delete', _layer[_localProp], undefined, [], '__kbmethodlisteners'),                            onMEvent = _onevent(eM);                        var e = new eventObject(_layer, key, 'delete', _layer[_localProp], undefined, [], '__kbdeletelisteners', this._stopChange),                            onEvent = _onevent(e);                        if (onEvent !== true && onMEvent !== true) {                            _layer = _layer.__kbnonproxy;                            Object.defineProperty(_layer, _localProp, setDescriptor(undefined, true, true, false));                            delete _layer[_localProp];                            if (_isNumber && _layer.length > parseInt(key, 10) && bypass) _layer.length = (_layer.length - 1);                            eM.type = 'postdelete';                            eM.listener = '__kbmethodupdatelisteners';                            _onevent(eM);                            e.listener = '__kbupdatelisteners';                            e.type = 'postdelete';                            e.oldValue = e.value;                            e.value = undefined;                            _onevent(e);                        }                    }                }                return this;            }            function move(obj, prop) {                this.__kbnonproxy.set(prop, obj[prop]);                if (!isMixed(obj)) {                    obj[prop] = null;                    delete obj[prop];                } else {                    obj.del(prop);                }                return this;            }            function copy(obj, key) {                var _layer = this.__kbnonproxy;                if (!isMixed(obj)) {                    _layer.set(key, obj[key]);                } else {                    if (obj.__kbname === 'default') {                        _layer.merge(obj[key], key);                    } else {                        _layer.addPointer(obj, key);                    }                }                return this;            }            function merge(obj, key) {                var cache = [],                    _layer = this.__kbnonproxy;                function recMerge(from, to) {                    var keys = (isMixed(from) ? from.keys('object') : Object.keys(from)),                        _curr;                    for (var x = 0, len = keys.length; x < len; x++) {                        _curr = from[keys[x]];                        if (typeof _curr === 'object' && cache.indexOf(_curr) === -1 && to[keys[x]] !== 'undefined') {                            recMerge(_curr, to);                        } else if (to[keys[x]] === undefined) {                            to.set(keys[x], (typeof _curr === 'object' ? {} : _curr));                        }                    }                }                if (key && _layer[key] === undefined) _layer.set(key, {});                recMerge(obj, (key ? _layer[key] : _layer));                return this;            }            function replace(obj, key) {                var cache = [],                    _layer = this.__kbnonproxy;                function recReplace(from, to) {                    var keys = (isMixed(from) ? from.keys('object') : Object.keys(from)),                        _curr;                    _curr = from[keys[x]];                    if (typeof _curr === 'object' && cache.indexOf(_curr) === -1 && to[keys[x]] !== 'undefined') {                        recReplace(_curr, to);                    } else {                        to.set(keys[x], (typeof _curr === 'object' ? {} : _curr));                    }                }                if (key && _layer[key] === undefined) _layer.set(key, {});                recReplace(obj, (key ? _layer[key] : _layer));                return this;            }            /* ENDREGION Object methods */            /* REGION Array methods */            function copyWithin(target, start, end) {                start = (start || 0);                end = (end || 0);                var e = new eventObject(this, target, 'copyWithin', this[target], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true && target < _layer.length) {                    target = (target < 0 ? (_layer.length - 1) : target);                    start = (start < _layer.length ? start : (_layer.length - 1));                    end = (end < _layer.length ? end : (_layer.length - 1));                    start = (start < 0 ? (_layer.length - 1) : start);                    end = (start < 0 ? (_layer.length - 1) : end);                    for (var x = start; x <= end; x++) {                        _layer.set((target + (x - start)), _layer[x]);                    }                    e.type = 'postcopyWithin';                    e.listener = '__kbmethodupdatelisteners'                    _onevent(e);                }                return this;            }            function fill(value, start, end) {                start = (start !== undefined ? Math.max(0, start) : 0);                end = ((end !== undefined && end <= this.length) ? Math.min(this.length, Math.max(0, end)) : this.length);                var e = new eventObject(this, _start, 'fill', this[_start], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    for (var x = a.key; x < end; x++) {                        _layer[x] = value;                    }                    e.type = 'postfill';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this;            }            function pop() {                var e = new eventObject(this, (this.length - 1), 'pop', this[(this.length - 1)], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    var _ret = _layer[(_layer.length - 1)];                    _layer.del((this.length - 1));                    e.type = 'postpop';                    e.listener = '__kbmethodupdatelisteners'                    _onevent(e);                    return _ret;                }                return null;            }            function push(v) {                var e = new eventObject(this, (this.length), 'push', v, undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    _layer.set(_layer.length, v);                    e.type = 'postpush';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this.length;            }            function reverse() {                var e = new eventObject(this, undefined, 'reverse', undefined, undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    var left = null,                        right = null,                        length = _layer.length;                    for (left = 0; left < length / 2; left += 1) {                        right = length - 1 - left;                        var temporary = _layer[left];                        _layer[left] = _layer[right];                        _layer[right] = temporary;                        temporary = null;                    }                    e.type = 'postreverse';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this;            }            function shift() {                var e = new eventObject(this, 0, 'shift', this[0], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    var _ret = _layer[a.key];                    for (var x = a.key, len = (this.length - 1); x < len; x++) {                        _layer[x] = _layer[(x + 1)];                    }                    _layer.del((this.length - 1));                    e.type = 'postshift';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return null;            }            function sort() {                var e = new eventObject(this, undefined, 'sort', undefined, undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    var _arrCopy = ArrSlice.call(_layer);                    ArrSort.apply(_arrCopy, arguments);                    for (var x = 0, len = _arrCopy.length; x < len; x++) {                        _layer[x] = _arrCopy[x];                    }                    e.type = 'postsort';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this;            }            function splice(index, remove, insert) {                index = (typeof index === 'string' ? parseInt(index, 10) : index);                var e = new eventObject(this, index, 'splice', undefined, undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy,                    _hasProxy = !!window.Proxy;                if (_onevent(e) !== true) {                    var _ret = [],                        _inserts = Array.prototype.slice.call(arguments, 2),                        _insertLen = (_inserts.length - 2),                        _index = 0;                    if (remove !== 0 && _layer[((index - 1) + remove)] !== undefined) {                        for (var x = 0, len = remove; x < len; x++) {                            _ret.push(_layer[index + x]);                            for (var i = (index + x), lenI = (this.length - 1); i < lenI; i++) {                                _layer[i] = _layer[(i + 1)];                            }                            _layer.del((_layer.length - 1), true)                        }                    }                    if (_insertLen !== 0) {                        for (var x = 0, len = _insertLen; x < len; x++) {                            _index = (index + (Math.min(1, x)));                            for (var i = _layer.length, lenI = _index; i > lenI; i--) {                                _layer.set(i, _layer[(i - 1)]);                            }                            _layer.set(_index, _inserts[x]);                        }                    }                    e.type = 'postsplice';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                    return _ret;                } else {                    return [];                }            }            function unshift() {                var e = new eventObject(this, 0, 'unshift', this[0], undefined, arguments, '__kbmethodlisteners'),                    _layer = this.__kbnonproxy;                if (_onevent(e) !== true) {                    var args = Array.prototype.slice.call(arguments);                    for (var x = ((_layer.length - 1) + args.length), len = args.length; x !== -1; x--) {                        if (x < len) {                            _layer.set(x, args[x]);                        } else {                            _layer.set(x, _layer[(x - args.length)]);                        }                    }                    e.type = 'postunshift';                    e.listener = '__kbmethodupdatelisteners';                    _onevent(e);                }                return this.length;            }            /* ENDREGION Array methods */            /* REGION Event Listeners */            function stopChange() {                this.__kbnonproxy._stopChange = true;                return this;            }            function splitScopeString(scopeString) {                return scopeString.split('.');            }            function setLayer(scopeString) {                var scope = splitScopeString(scopeString);                function rec(scope) {                    var key = scope[0];                    if (this[key] === undefined && (scope.length - 1) !== 0) this[key] = Mixed({}, this.__kbname, this, this.__kbscopeString + "." + key);                    if (!isMixed(this[key])) return this;                    if ((scope.length - 1) !== 0) {                        scope.shift();                        return rec.call(this[key], scope);                    }                    return this[key];                }                return rec.call(this, scope);            }            function getLayer(scopeString) {                var scope = splitScopeString(scopeString);                function rec(scope) {                    var key = scope[0];                    if (this[key] === undefined && (scope.length - 1) !== 0) return null;                    if (!isMixed(this[key])) return this;                    if ((scope.length - 1) !== 0) {                        scope.shift();                        return rec.call(this[key], scope);                    }                    return this[key];                }                return rec.call(this, scope);            }            function addListener(type, listener) {                return function(prop, func) {                    arguments = Array.prototype.slice.call(arguments);                    arguments.push(type);                    var _listeners = this[listener],                        e = new eventObject(this, listener, 'addlistener', _listeners, undefined, arguments, ''),                        _layer = this.__kbnonproxy;                    if (typeof prop === 'string' && splitScopeString(prop).length !== 1) {                        var scopeString = splitScopeString(prop);                        prop = scopeString.pop();                        scopeString = scopeString.join(".");                        e.local = this.getLayer(scopeString);                        _listeners = e.local[listener];                        e.value = _listeners;                    }                    if (_onevent(e) !== true) {                        if (isObject.call(_listeners)) {                            if (_listeners[prop] === undefined) _listeners[prop] = [];                            _listeners[prop].push(func);                            e.type = 'postaddlistener'                            _onevent(e);                        } else if (isArray.call(_listeners)) {                            if (typeof prop === 'function') {                                _listeners.push(prop);                                e.type = 'postaddlistener'                                _onevent(e);                            }                        }                    }                    return this;                }            }            function removeListener(type, listener) {                return function(prop, func) {                    arguments = Array.prototype.slice.call(arguments);                    arguments.push(type);                    var _listeners = this[listener],                        e = new eventObject(this, listener, 'removelistener', _listeners, undefined, arguments, ''),                        _layer = this.__kbnonproxy;                    if (typeof prop === 'string' && splitScopeString(prop).length !== 1) {                        var scopeString = splitScopeString(prop);                        scopeString.pop();                        scopeString.join(".");                        e.local = this.getLayer(scopeString);                        _listeners = e.local[listener];                        e.value = _listeners;                        prop = splitScopeString(prop).pop();                    }                    if (_onevent(e) !== true) {                        if (isObject.call(_listeners)) {                            if (_listeners[prop] !== undefined) {                                for (var x = 0, len = _listeners[prop].length; x < len; x++) {                                    if (_listeners[prop][x].toString() === func.toString()) {                                        _listeners[prop].splice(x, 1);                                        e.type = 'postremovelistener';                                        _onevent(e);                                        break;                                    }                                }                            }                        } else if (isArray.call(_listeners)) {                            if (typeof prop === 'function') {                                for (var x = 0, len = _listeners.length; x < len; x++) {                                    if (_listeners[x].toString() === prop.toString()) {                                        _listeners.splice(x, 1);                                        e.type = 'postremovelistener';                                        _onevent(e);                                        break;                                    }                                }                            }                        }                    }                    return this;                }            }            function addActionListener(type, func) {                var _layer = this.__kbnonproxy;                if (_layer.__kbref.__kbevents[type] !== undefined) {                    _layer.__kbref.__kbevents[type].push(func);                }                return this;            }            function removeActionListener(type, func) {                var _layer = this.__kbnonproxy;                if (_layer.__kbref.__kbevents[type] !== undefined) {                    for (var x = 0, len = _layer.__kbref.__kbevents[type]; x < len; x++) {                        if (_layer.__kbref.__kbevents[type][x].toString() === func.toString()) {                            _layer.__kbref.__kbevents[type].splice(x, 1);                            break;                        }                    }                }                return this;            }            function addChildListener(type, listener) {                function recAddListener(prop, func, listener) {                    var children = Object.keys(this, 'all').filter((function(p) {                        return (isMixed.call(this[p]));                    }).bind(this));                    var _local = this,                        _locProp = prop;                    if (typeof prop === 'string' && splitScopeString(prop).length !== 1) {                        var scopeString = splitScopeString(prop);                        _locProp = scopeString.pop();                        scopeString = scopeString.join(".");                        _local = this.getLayer(scopeString);                        if (_local[listener][_locProp] === undefined) _local[listener][_locProp] = [];                        _local[listener][_locProp].push(func);                    }                    if (isObject.call(_local[listener])) {                        if (_local[listener][_locProp] === undefined) _local[listener][_locProp] = [];                        _local[listener][_locProp].push(func);                        var localPointer = _local.__kbpointers[_locProp],                            localLayer = localPointer.point.getLayer(localPointer.keys);                        if (localLayer[_locProp] !== undefined) {                            if (localLayer[listener][_locProp] === undefined) localLayer[listener][_locProp] = [];                            localLayer[listener][_locProp].push(_func);                        }                    } else {                        _local[listener].push(func);                    }                    for (var x = 0, len = children.length; x < len; x++) {                        recAddListener.call(this[children[x]], prop, func, listener);                    }                }                return function(prop, func) {                    arguments = Array.prototype.slice.call(arguments);                    arguments.push(type);                    var e = new eventObject(this, listener, 'addchildlistener', undefined, undefined, arguments, '');                    if (_onevent(e) !== true) {                        recAddListener.call(this.__kbnonproxy, prop, func, listener);                        e.type = 'postaddchildlistener';                        _onevent(e);                    }                    return this;                }            }            function removeChildListener(type, listener) {                function recRemoveListener(prop, func, listener) {                    var children = Object.keys(this, 'all').filter((function(p) {                        return (isMixed.call(this[p]));                    }).bind(this));                    var _local = this,                        _locProp = prop;                    if (typeof prop === 'string' && splitScopeString(prop).length !== 1) {                        var scopeString = splitScopeString(prop);                        _locProp = scopeString.pop();                        scopeString.join(".");                        _local = this.getLayer(scopeString);                        if (_local[listener][prop] !== undefined) {                            for (var x = 0, len = _local[listener][prop].length; x < len; x++) {                                if (_local[listener][prop][x].toString() === func.toString()) {                                    _local[listener][prop].splice(x, 1);                                    break;                                }                            }                        }                    }                    if (isObject.call(_local[listener])) {                        if (_local[listener][_locProp] !== undefined) {                            for (var x = 0, len = _local[listener][_locProp].length; x < len; x++) {                                if (_local[listener][_locProp][x].toString() === func.toString()) {                                    _local[listener][_locProp].splice(x, 1);                                    break;                                }                            }                            if (_local.__kbpointers.indexOf(_locProp) !== -1) {                                var localPointer = _local.__kbpointers[_locProp],                                    localLayer = localPointer.point.getLayer(localPointer.keys);                                if (localLayer[listener][_locProp] !== undefined) {                                    for (var x = 0, len = localLayer[listener][_locProp].length; x < len; x++) {                                        if (localLayer[listener][_locProp][x].toString() === func.toString()) {                                            localLayer[listener][_locProp].splice(x, 1);                                            break;                                        }                                    }                                }                            }                        }                    } else {                        for (var x = 0, len = _local[listener].length; x < len; x++) {                            if (_local[listener][x].toString() === func.toString()) {                                _local[listener].splice(x, 1);                                break;                            }                        }                    }                    for (var x = 0, len = children.length; x < len; x++) {                        recRemoveListener.call(this[children[x]], prop, func, listener);                    }                }                return function(prop, func) {                    arguments = Array.prototype.slice.call(arguments);                    arguments.push(type);                    var e = new eventObject(this, listener, 'removechildlistener', undefined, undefined, arguments, '');                    if (_onevent(e) !== true) {                        recRemoveListener.call(this.__kbnonproxy, prop, func, listener);                        e.type = 'postremovechildlistener';                        _onevent(e);                    }                    return this;                }            }            function subscribe(prop, func) {                var _split = prop.split('.'),                    _key = _split.pop(),                    _layer = (_split.length !== 0 ? this.__kbnonproxy.getLayer(_split.join('.')) : this.__kbnonproxy);                if (_layer.__kbsubscribers[_key] === undefined) _layer.__kbsubscribers[_key] = [];                _layer.__kbsubscribers[_key].push(func);                return this;            }            function subscribeDeep(prop, func) {                var _multi = (prop.indexOf('*') !== -1),                    _split = prop.split('.'),                    _preSplit = _split.slice(0, _split.indexOf('*')),                    _multiSplit = (_split.indexOf('*') !== -1 ? _split.slice(_split.indexOf('*'), _split.length) : []),                    _multiSplitSingle = (_multiSplit.length === 1),                    _key = _split.pop(),                    _layer = (_split.length !== 0 ? this.__kbnonproxy.getLayer(_split.join('.')) : this.__kbnonproxy);                function recsubscribe(local, key) {                    var children = Object.keys(local, 'all').filter((function(p) {                        return (isMixed.call(local[p]));                    }).bind(local));                    if (local[key] !== undefined || key === '*') {                        if (local.__kbparentsubscribers[key] === undefined) local.__kbparentsubscribers[key] = [];                        local.__kbparentsubscribers[key].push(func);                    }                    for (var x = 0, len = children.length; x < len; x++) {                        recsubscribe(local[children[x]], key);                    }                }                if (!_multi) {                    recsubscribe(_layer, _key);                } else {                    if (!_multiSplitSingle) {                        _multiSplit.shift();                        _layer.subscribeDeep(_multiSplit.join('.'), func);                    } else {                        recsubscribe(_layer, '*');                    }                }                return this;            }            function unsubscribe(prop, func) {                var _multi = (prop === '*'),                    _split = prop.split('.'),                    _key = _split.pop(),                    _layer = (_split.length !== 0 ? this.__kbnonproxy.getLayer(_split.join('.')) : this.__kbnonproxy);                if (_layer.__kbsubscribers[_key] !== undefined) {                    for (var x = 0, len = _layer.__kbsubscribers[_key].length; x < len; x++) {                        if (_layer.__kbsubscribers[_key][x].toString() === func.toString()) {                            _layer.__kbsubscribers[_key].splice(x, 1);                            break;                        }                    }                }                return this;            }            function unsubscribeDeep(prop, func) {                var _multi = (prop.indexOf('*') !== -1),                    _split = prop.split('.'),                    _preSplit = _split.slice(0, _split.indexOf('*')),                    _multiSplit = (_split.indexOf('*') !== -1 ? _split.slice(_split.indexOf('*'), _split.length) : []),                    _multiSplitSingle = (_multiSplit.length === 1),                    _key = _split.pop(),                    _layer = (_split.length !== 0 ? this.__kbnonproxy.getLayer(_split.join('.')) : this.__kbnonproxy);                function recunsibscribe(local, key) {                    var children = Object.keys(local, 'all').filter((function(p) {                        return (isMixed.call(local[p]) && !(local[p] instanceof HTMLElement));                    }).bind(local));                    if (local[key] !== undefined || key === '*') {                        if (local.__kbparentsubscribers[key] !== undefined) {                            for (var x = 0, len = local.__kbparentsubscribers[key].length; x < len; x++) {                                if (local.__kbparentsubscribers[key][x].toString() === func.toString()) local.__kbparentsubscribers[key].splice(x, 1);                            }                        }                    }                    for (var x = 0, len = children.length; x < len; x++) {                        recunsibscribe(local[children[x]], key);                    }                }                if (!_multi) {                    recunsibscribe(_layer, _key);                } else {                    if (!_multiSplitSingle) {                        _multiSplit.shift();                        _layer.unsubscribeDeep(_multiSplit.join('.'), func);                    } else {                        recunsibscribe(_layer, '*');                    }                }                return this;            }            function callSubscribers(kbref, obj, prop, value, oldValue, stopChange) {                var _layer = this.__kbnonproxy;                if (_layer.__kbsubscribers[prop] !== undefined) {                    for (var x = 0, len = _layer.__kbsubscribers[prop].length; x < len; x++) {                        _layer.__kbsubscribers[prop][x].call(this, {                            key: prop,                            value: value,                            oldValue: oldValue,                            stopChange: stopChange,                            local: obj,                            kbref: kbref                        });                    }                }                if (_layer.__kbparentsubscribers[prop] !== undefined) {                    for (var x = 0, len = _layer.__kbparentsubscribers[prop].length; x < len; x++) {                        _layer.__kbparentsubscribers[prop][x].call(this, {                            key: prop,                            value: value,                            oldValue: oldValue,                            stopChange: stopChange,                            local: obj,                            kbref: kbref                        });                    }                }                if (_layer.__kbsubscribers['*'] !== undefined) {                    for (var x = 0, len = _layer.__kbsubscribers['*'].length; x < len; x++) {                        _layer.__kbsubscribers['*'][x].call(this, {                            key: prop,                            value: value,                            oldValue: oldValue,                            stopChange: stopChange,                            local: obj,                            kbref: kbref                        });                    }                }                if (_layer.__kbparentsubscribers['*'] !== undefined) {                    for (var x = 0, len = _layer.__kbparentsubscribers['*'].length; x < len; x++) {                        _layer.__kbparentsubscribers['*'][x].call(this, {                            key: prop,                            value: value,                            oldValue: oldValue,                            stopChange: stopChange,                            local: obj,                            kbref: kbref                        });                    }                }                return this;            }            function callAllSubscribers() {                var _layer = this.__kbnonproxy;                function loop(local, subs, key) {                    for (var x = 0, len = subs.length; x < len; x++) {                        subs[x].call(local, {                            key: key,                            value: local[key],                            oldValue: local[key],                            stopChange: false,                            local: local,                            kbref: local.__kbref,                            initial: true                        });                    }                }                function recCall(local) {                    var subscribers = Object.keys(local.__kbsubscribers),                        parentSubscribers = Object.keys(local.__kbparentsubscribers);                    for (var x = 0, len = subscribers.length; x < len; x++) {                        if (local.__kbsubscribers[subscribers[x]].length !== 0) {                            if (subscribers[x] === '*') {                                for (var i = 0, keys = Object.keys(local), lenn = keys.length; i < lenn; i++) {                                    loop(local, local.__kbsubscribers[subscribers[x]], keys[i]);                                }                            } else {                                loop(local, local.__kbsubscribers[subscribers[x]], subscribers[x]);                            }                        }                    }                    for (var x = 0, len = parentSubscribers.length; x < len; x++) {                        if (local.__kbparentsubscribers[parentSubscribers[x]].length !== 0) {                            if (parentSubscribers[x] === '*') {                                for (var i = 0, keys = Object.keys(local), lenn = keys.length; i < lenn; i++) {                                    loop(local, local.__kbparentsubscribers[parentSubscribers[x]], keys[i]);                                }                            } else {                                loop(local, local.__kbparentsubscribers[parentSubscribers[x]], parentSubscribers[x]);                            }                        }                    }                }                recCall(_layer);                return this;            }            /* ENDREGION Event Listeners */            Object.defineProperties(Mixed.prototype, {                /* Helper methods */                typeof: setDescriptor(type, false, true),                sizeof: setDescriptor(sizeof, false, true),                isObject: setDescriptor(isObject, false, true),                isArray: setDescriptor(isArray, false, true),                isMixed: setDescriptor(isMixed, false, true),                isObservable: setDescriptor(isObservable, false, true),                stringify: setDescriptor(stringify, false, true),                getKeys: setDescriptor(getKeys, false, true),                getIndexes: setDescriptor(getIndexes, false, true),                keyCount: setCustomDescriptor(keyCount, false, true),                indexCount: setCustomDescriptor(indexCount, false, true),                count: setCustomDescriptor(count, false, true),                /* Non destructive Array methods */                concat: setDescriptor(Array.prototype.concat),                every: setDescriptor(Array.prototype.every),                filter: setDescriptor(Array.prototype.filter),                find: setDescriptor(Array.prototype.find),                findIndex: setDescriptor(Array.prototype.findIndex),                forEach: setDescriptor(Array.prototype.forEach),                includes: setDescriptor(Array.prototype.includes),                indexOf: setDescriptor(Array.prototype.indexOf),                join: setDescriptor(Array.prototype.join),                lastIndexOf: setDescriptor(Array.prototype.lastIndexOf),                map: setDescriptor(Array.prototype.map),                reduce: setDescriptor(Array.prototype.reduce),                reduceRight: setDescriptor(Array.prototype.reduceRight),                slice: setDescriptor(Array.prototype.slice),                some: setDescriptor(Array.prototype.some),                entries: setDescriptor(Array.prototype.entries),                toLocaleString: setDescriptor(Array.prototype.toLocaleString),                parse: setDescriptor(parse, true),                parseReplace: setDescriptor(parseReplace, true),                /* Object Methods */                add: setDescriptor(add),                set: setDescriptor(set),                get: setDescriptor(get),                del: setDescriptor(del),                exists: setDescriptor(exists),                addPrototype: setDescriptor(addPrototype),                addPointer: setDescriptor(addPointer),                move: setDescriptor(move),                copy: setDescriptor(copy),                merge: setDescriptor(merge),                replace: setDescriptor(replace),                /* Array Methods */                copyWithin: setDescriptor(copyWithin),                fill: setDescriptor(fill),                pop: setDescriptor(pop),                push: setDescriptor(push),                reverse: setDescriptor(reverse),                shift: setDescriptor(shift),                sort: setDescriptor(sort),                splice: setDescriptor(splice),                unshift: setDescriptor(unshift),                /* Helpers */                getLayer: setDescriptor(getLayer),                setLayer: setDescriptor(setLayer),                ignoreCreate: setDescriptor(ignoreCreate),                /* Event Listeners */                addActionListener: setDescriptor(addActionListener),                removeActionListener: setDescriptor(removeActionListener),                subscribe: setDescriptor(subscribe),                unsubscribe: setDescriptor(unsubscribe),                subscribeDeep: setDescriptor(subscribeDeep),                unsubscribeDeep: setDescriptor(unsubscribeDeep),                callSubscribers: setDescriptor(callSubscribers),                callAllSubscribers: setDescriptor(callAllSubscribers),                stopChange: setDescriptor(stopChange)            });            Object.defineProperties(Mixed.prototype, {                /* Standard Data Listeners as a single layer */                addDataListener: setDescriptor(addListener('addDataListener', '__kblisteners')),                removeDataListener: setDescriptor(removeListener('removeDataListener', '__kblisteners')),                addDataUpdateListener: setDescriptor(addListener('addDataUpdateListener', '__kbupdatelisteners')),                removeDataUpdateListener: setDescriptor(removeListener('removeDataUpdateListener', '__kbupdatelisteners')),                addDataCreateListener: setDescriptor(addListener('addDataCreateListener', '__kbcreatelisteners')),                removeDataCreateListener: setDescriptor(removeListener('removeDataCreateListener', '__kbcreatelisteners')),                addDataDeleteListener: setDescriptor(addListener('addDataDeleteListener', '__kbdeletelisteners')),                removeDataDeleteListener: setDescriptor(removeListener('removeDataDeleteListener', '__kbdeletelisteners')),                addDataMethodListener: setDescriptor(addListener('addDataMethodListener', '__kbmethodlisteners')),                removeDataMethodListener: setDescriptor(removeListener('removeDataMethodListener', '__kbmethodlisteners')),                addDataMethodUpdateListener: setDescriptor(addListener('addDataMethodUpdateListener', '__kbmethodupdatelisteners')),                removeDataMethodUpdateListener: setDescriptor(removeListener('removeDataMethodUpdateListener', '__kbmethodupdatelisteners')),                /* MultiLayer Child Listeners */                addChildDataListener: setDescriptor(addChildListener('addChildDataListener', '__kbparentlisteners')),                removeChildDataListener: setDescriptor(removeChildListener('removeChildDataListener', '__kbparentlisteners')),                addChildDataUpdateListener: setDescriptor(addChildListener('addChildDataUpdateListener', '__kbparentupdatelisteners')),                removeChildDataUpdateListener: setDescriptor(removeChildListener('removeChildDataUpdateListener', '__kbparentupdatelisteners')),                addChildDataCreateListener: setDescriptor(addChildListener('addChildDataCreateListener', '__kbparentcreatelisteners')),                removeChildDataCreateListener: setDescriptor(removeChildListener('removeChildDataCreateListener', '__kbparentcreatelisteners')),                addChildDataDeleteListener: setDescriptor(addChildListener('addChildDataDeleteListener', '__kbparentdeletelisteners')),                removeChildDataDeleteListener: setDescriptor(removeChildListener('removeChildDataDeleteListener', '__kbparentdeletelisteners')),            });            return Mixed;        }        return CreateKonnektDT;    }());    var CreateKonnektL = (function() {        function CreateKonnektL() {            var _onload = function() {},                _reNodes = /(<\/.*?>)/g;            if (!window.K_Components) window.K_Components = {};            /* main takes name and loads file, after load it checks html and cms html if applicable */            function KonnektL(name) {                function onLoad(method) {                    var unknowns = KonnektL.getUnknowns(method.prototype.k_html);                    if (method.k_cms) {                        unknowns.concat(KonnektL.getUnknowns(method.k_cms.prototype.kcms_html));                    }                    if (unknowns.length !== 0) KonnektL(unknowns);                }                if (typeof name === 'object') {                    for (var x = 0, len = name.length; x < len; x++) {                        if (!K_Components[name[x]]) {                            KonnektL.load(name[x], 'component/' + name[x] + '/' + location.search, _onload);                        } else {                            _onload(name[x], K_Components[name[x]], document.getElementById('script_' + name[x]));                        }                    }                } else if (typeof name === 'string') {                    if (!K_Components[name[x]]) {                        KonnektL.load(name, 'component/' + name + '/' + location.search, _onload);                    } else {                        _onload(name, K_Components[name], document.getElementById('script_' + name));                    }                }            }            /* checks for unregistered components in the html */            KonnektL.getUnknowns = function(html) {                var matched = html.match(_reNodes);                return matched.map(function(k) {                        return k.replace(/[<\/>]/g, "");                    })                    .filter(function(k, i) {                        return ((document.createElement(k) instanceof HTMLUnknownElement) && (matched.indexOf(k, (i + 1)) === -1) && !K_Components[k]);                    });            }            /* loads script tag into html */            KonnektL.load = function(name, url, cb) {                function createNode(name, src, fn) {                    var node = document.createElement('script');                    node.type = 'text/javascript';                    node.charset = 'utf-8';                    node.async = true;                    node.src = src;                    node.id = 'script_' + name;                    node.onload = function() {                        fn(name, K_Components[name], this);                    };                    return node;                }                document.head.appendChild(createNode(name, url, cb));                return KonnektL;            }            KonnektL.onLoad = function(v) {                if (v === undefined) return _onload;                _onload = (typeof v === 'function' ? v : _onload);                return KonnektL;            }            return KonnektL;        }        return CreateKonnektL;    }())    var Createkb = (function() {        function CreateKB() {            /* This holds global attribute listeners when tied to kb */            var _attrListeners = {},                /* This holds global attribute update listeners when tied to kb */                _attrUpdateListeners = {},                /* This holds global style listeners when tied to kb */                _styleListeners = {},                /* This holds global style update listeners when tied to kb */                _styleUpdateListeners = {},                /* This holds all injected objects, so You can see what is injected */                _injected = {},                /* The symbol to dignify what the master global listener is */                _all = '*',                _texts = ['textContent', 'innerHTML', 'innerText', 'outerHTML', 'outerText', 'appendChild', 'removeChild', 'replaceChild', 'insertAdjacentHTML', 'insertBefore'],                /* A master list of all style prop names */                _allStyles = Object.getOwnPropertyNames(document.documentElement.style),                _allEvents = Object.keys(HTMLElement.prototype).filter(function(v) {                    return (v.indexOf('on') === 0);                }).concat(['addEventListener', 'removeEventListener']),                /* global iterators */                x,                i,                /* Default set method for all listeners, loops through and runs all attached listeners */                _set = function(el, prop, val, ret, args, stopChange) {                    var e = new _changeEvent(el, prop, val, ret, args, undefined, 'set', stopChange);                    if (el.__kb !== undefined) {                        var localAttrListeners = el.__kb._attrListeners,                            localStyleListeners = el.__kb._styleListeners,                            localParentAttrListeners = el.__kb._parentAttrListeners,                            localParentStyleListeners = el.__kb._parentStyleListeners;                        if (localAttrListeners[prop] !== undefined) {                            loopListener(localAttrListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localStyleListeners[prop] !== undefined) {                            loopListener(localStyleListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localAttrListeners[_all] !== undefined) {                            loopListener(localAttrListeners[_all], e);                            if (e._stopPropogation === undefined) {                                loopListener(localStyleListeners[_all], e);                            }                        }                        if (e._stopPropogation === undefined && localParentAttrListeners[prop] !== undefined) {                            loopParentListener(localParentAttrListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localParentStyleListeners[prop] !== undefined) {                            loopParentListener(localParentStyleListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localParentAttrListeners[_all] !== undefined) {                            loopParentListener(localParentAttrListeners[_all], e);                            if (e._stopPropogation === undefined) {                                loopParentListener(localParentStyleListeners[_all], e);                            }                        }                    }                    if (e._stopPropogation === undefined && _attrListeners[prop] !== undefined) {                        loopListener(_attrListeners[prop], e);                    }                    if (e._stopPropogation === undefined && _styleListeners[prop] !== undefined) {                        loopListener(_styleListeners[prop], e);                    }                    if (e._stopPropogation === undefined && _attrListeners[_all] !== undefined) {                        loopListener(_attrListeners[_all], e);                        if (e._stopPropogation === undefined) {                            loopListener(_styleListeners[_all], e);                        }                    }                    if (e._preventDefault !== undefined) return false;                    return true;                },                /* Default update method for all listeners, loops through and runs all attached update listeners */                _update = function(el, prop, val, ret, args, action) {                    var e = new _changeEvent(el, prop, val, ret, args, action, 'update');                    if (el.__kb !== undefined) {                        var localAttrListeners = el.__kb._attrUpdateListeners,                            localStyleListeners = el.__kb._styleUpdateListeners,                            localParentAttrListeners = el.__kb._parentAttrUpdateListeners,                            localParentStyleListeners = el.__kb._parentStyleUpdateListeners;                        if (localAttrListeners[prop] !== undefined) {                            loopListener(localAttrListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localStyleListeners[prop] !== undefined) {                            loopListener(localStyleListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localAttrListeners[_all] !== undefined) {                            loopListener(localAttrListeners[_all], e);                            if (e._stopPropogation === undefined) {                                loopListener(localStyleListeners[_all], e);                            }                        }                        if (e._stopPropogation === undefined && localParentAttrListeners[prop] !== undefined) {                            loopParentListener(localParentAttrListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localParentStyleListeners[prop] !== undefined) {                            loopParentListener(localParentStyleListeners[prop], e);                        }                        if (e._stopPropogation === undefined && localParentAttrListeners[_all] !== undefined) {                            loopParentListener(localParentAttrListeners[_all], e);                            if (e._stopPropogation === undefined) {                                loopParentListener(localParentStyleListeners[_all], e);                            }                        }                    }                    if (e._stopPropogation === undefined && _attrUpdateListeners[prop] !== undefined) {                        loopListener(_attrUpdateListeners[prop], e);                    }                    if (e._stopPropogation === undefined && _styleUpdateListeners[prop] !== undefined) {                        loopListener(_styleUpdateListeners[prop], e);                    }                    if (e._stopPropogation === undefined && _attrUpdateListeners[_all] !== undefined) {                        loopListener(_attrUpdateListeners[_all], e);                        if (e._stopPropogation === undefined) {                            loopListener(_styleUpdateListeners[_all], e);                        }                    }                    if (e._preventDefault !== undefined) return false;                    return true;                }            /* Helper method to loop through listeners and run them */            function loopListener(looper, e) {                var _looper = looper,                    _len = looper.length,                    _e = e,                    _x;                for (_x = 0; _x < _len; _x++) {                    looper[_x](_e);                    if (_e._stopPropogation !== undefined) break;                }            }            /* Helper method to loop through all parent listeners and run them */            function loopParentListener(looper, e) {                var _looper = looper,                    _len = looper.length,                    _e = e,                    _x;                for (_x = 0; _x < _len; _x++) {                    _e.child = _e.target;                    _e.target = looper[_x].parent;                    looper[_x].func(_e);                    if (_e._stopPropogation !== undefined) break;                }            }            /* Helper method to loop through all listeners and return if a method exists */            function loopListenerCheck(looper, func) {                var _looper = looper,                    _len = looper.length,                    _func = func,                    _x;                for (_x = 0; _x < _len; x++) {                    if (_looper[x].toString() === _func.toString()) return true;                }                return false;            }            /* The event object that gets passed to each listener */            function _changeEvent(el, attr, value, oldValue, args, action, type, stopChange) {                this.stopPropagation = function() {                    this._stopPropogation = true;                };                this.preventDefault = function() {                    this._preventDefault = true;                };                this.value = value;                this.oldValue = oldValue;                this.target = el;                this.attr = attr;                this.arguments = args;                this.action = action;                this.child = undefined;                this.type = type;                this.stopChange = stopChange;            }            /* This holds all listeners associated with a particular element */            function _localBinders() {                this._attrListeners = {};                this._attrUpdateListeners = {};                this._styleListeners = {};                this._styleUpdateListeners = {};                this._parentStyleListeners = {};                this._parentStyleUpdateListeners = {};                this._parentAttrListeners = {};                this._parentAttrUpdateListeners = {};                this._injectedStyle = {};            }            /* This is a standard property set overwrite  */            function setStandard(descriptor, key, set, update) {                var _descriptor = descriptor,                    _descGet = _descriptor.get,                    _descSet = _descriptor.set,                    _key = key,                    _set = set,                    _update = update,                    _oldValue;                return function standardSet(v) {                    _oldValue = _descGet.call(this);                    if (_set(this, _key, v, _oldValue, undefined, this._stopChange)) {                        _descSet.call(this, v);                    }                    if (!this._stopChange) {                        _update(this, _key, v, _oldValue);                    }                    this._stopChange = undefined;                }            }            /* This is a standard value set overwrite */            function setValue(descriptor, key, set, update) {                var _descriptor = descriptor,                    _key = key,                    _set = set,                    _update = update,                    _oldValue;                return function valueSet(v) {                    _oldValue = _descriptor.value;                    if (_set(this, _key, v, _oldValue, arguments, this._stopChange)) {                        _descriptor.value = v;                    }                    if (!this._stopChange) {                        _update(this, _key, v, _oldValue, arguments);                    }                    this._stopChange = undefined;                }            }            /* This is a standard function overwrite  */            function setFunction(descriptor, key, set, update) {                var _descriptor = descriptor,                    _descVal = _descriptor.value,                    _key = key,                    _set = set,                    _update = update,                    _action;                return function functionSet() {                    if (_set(this, _key, null, null, arguments, this._stopChange)) {                        _action = _descVal.apply(this, arguments);                    }                    if (!this._stopChange) {                        _update(this, _key, null, null, arguments, _action);                    }                    this._stopChange = undefined;                    return _action;                }            }            /* This overwites a style property */            function setStyle(descriptor, key, set, update, el) {                var _proto = el.style,                    _descriptor = descriptor,                    _key = key,                    _keyCP = key.replace(/([A-Z])/g, "-$1").replace('webkit', '-webkit'),                    _set = set,                    _update = update,                    _el = el,                    _oldValue,                    _value;                return {                    get: function() {                        return _value;                    },                    set: function styleSet(v) {                        _oldValue = _value;                        if (_set(_el, _key, v, _oldValue, undefined, this._stopChange)) {                            _value = v;                            _proto.setProperty(_keyCP, v);                        }                        if (!this._stopChange) {                            _update(_el, _key, v, _oldValue);                        }                        this._stopChange = undefined;                    },                    enumerable: true,                    configurable: true                }            }            /* A helper method that is run for all addListener methods */            function addListener(attr, func, child, update) {                if (typeof func !== 'function') return bind;                var isInput = (['value', 'checked'].indexOf(attr) !== -1),                    isStyle = (_allStyles.indexOf(attr) !== -1),                    listeners;                if (this.toString() !== bind.toString()) {                    if (child) {                        var children = this.querySelectorAll('*'),                            len = children.length,                            listenerObj;                        for (var x = 0; x < len; x++) {                            listenerObj = children[x].attrListeners();                            if (isInput || (attr === _all)) {                                if (children[x].addInputBinding !== undefined) children[x].addInputBinding();                                if (children[x].addInputBoxBinding !== undefined) children[x].addInputBoxBinding();                            }                            if (isStyle) {                                bind.injectStyleProperty(children[x], attr);                                listeners = (update ? '_parentStyleUpdateListeners' : '_parentStyleListeners');                                if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                                listenerObj[listeners][attr].push({                                    parent: this,                                    func: func                                });                            } else {                                if (attr === _all) {                                    listeners = (update ? '_parentStyleUpdateListeners' : '_parentStyleListeners');                                    var len = _allStyles.length;                                    for (var i = 0; i < len; i++) {                                        bind.injectStyleProperty(children[x], _allStyles[i]);                                    }                                    if (listenerObj[listeners][_all] === undefined) listenerObj[listeners][_all] = [];                                    listenerObj[listeners][_all].push({                                        parent: this,                                        func: func                                    });                                }                                listeners = (update ? '_parentAttrUpdateListeners' : '_parentAttrListeners');                                if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                                listenerObj[listeners][attr].push({                                    parent: this,                                    func: func                                });                            }                        }                    } else {                        listenerObj = this.attrListeners();                        if (isStyle) {                            listeners = (update ? '_styleUpdateListeners' : '_styleListeners');                            bind.injectStyleProperty(this, attr);                            if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                            listenerObj[listeners][attr].push(func);                        } else {                            if (isInput || (attr === _all)) {                                if (this.addInputBinding !== undefined) this.addInputBinding();                                if (this.addInputBoxBinding !== undefined) this.addInputBoxBinding();                            }                            if (attr === _all) {                                listeners = (update ? '_styleUpdateListeners' : '_styleListeners');                                var len = _allStyles.length;                                for (var x = 0; x < len; x++) {                                    bind.injectStyleProperty(this, _allStyles[x]);                                }                                if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                                listenerObj[listeners][attr].push(func);                            }                            listeners = (update ? '_attrUpdateListeners' : '_attrListeners');                            if (listenerObj[listeners][attr] === undefined) listenerObj[listeners][attr] = [];                            listenerObj[listeners][attr].push(func);                        }                    }                } else {                    if (isInput || (attr === _all)) {                        var inputs = document.querySelectorAll('input, textarea'),                            len = inputs.length;                        for (var x = 0; x < len; x++) {                            if (inputs[x].addInputBinding !== undefined) inputs[x].addInputBinding();                            if (inputs[x].addInputBoxBinding !== undefined) inputs[x].addInputBoxBinding();                        }                    }                    if (isStyle) {                        var els = Array.prototype.slice.call(document.body.querySelectorAll('*')),                            len = (els.length + 1);                        els.unshift(document.body);                        for (var x = 0; x < len; x++) {                            bind.injectStyleProperty(els[x], attr);                        }                        listeners = (update ? _styleUpdateListeners : _styleListeners);                        if (listeners[attr] === undefined) listeners[attr] = [];                        listeners[attr].push(func);                    } else {                        if (attr === _all) {                            var els = Array.prototype.slice.call(document.body.querySelectorAll('*')),                                len = (els.length + 1),                                lenStyles = _allStyles.length;                            els.unshift(document.body);                            for (var x = 0; x < len; x++) {                                for (var i = 0; i < lenStyles; i++) {                                    bind.injectStyleProperty(els[x], _allStyles[i]);                                }                            }                            listeners = (update ? _styleUpdateListeners : _styleListeners);                            if (listeners[attr] === undefined) listeners[attr] = [];                            listeners[attr].push(func);                        }                        listeners = (update ? _attrUpdateListeners : _attrListeners);                        if (listeners[attr] === undefined) listeners[attr] = [];                        listeners[attr].push(func);                    }                }            }            /* A helper method that is ran for all removeListener methods */            function removeListener(attr, func, child, update) {                if (typeof func !== 'function') return bind;                var isInput = (['value', 'checked'].indexOf(attr) !== -1),                    isStyle = (_allStyles.indexOf(attr) !== -1),                    listeners,                    x;                function cut(attr, list) {                    var listenerFuncs = list[attr],                        len = listenerFuncs.length;                    for (x = 0; x < len; x++) {                        if (listenerFuncs[x].toString() === func.toString()) {                            listenerFuncs.splice(x, 1);                        }                    }                }                if (this.toString() !== bind.toString()) {                    if (child) {                        var children = this.querySelectorAll('*'),                            len = children.length;                        if (isStyle) {                            listeners = (update ? '_childStyleUpdateListeners' : '_childStyleListeners');                            cut(attr, this.attrListeners()[listeners]);                            listeners = (update ? '_parentStyleUpdateListeners' : '_parentStyleListeners');                        } else {                            if (attr === _all) {                                listeners = (update ? '_childStyleUpdateListeners' : '_childStyleListeners');                                cut(attr, this.attrListeners()[listeners]);                            }                            listeners = (update ? '_childAttrUpdateListeners' : '_childAttrListeners');                            cut(attr, this.attrListeners()[listeners]);                            listeners = (update ? '_parentAttrUpdateListeners' : '_parentAttrListeners');                        }                        for (x = 0; x < len; x++) {                            var parents = children[x].attrListeners()[listeners][attr],                                parentLen = parents.length;                            for (var i = 0; i < parentLen; i++) {                                if (parents[i].isEqualNode(this)) {                                    parents.slice(i, 1);                                }                            }                            if (attr === _all) {                                listenersStyle = (update ? '_parentStyleUpdateListeners' : '_parentStyleListeners');                                var parents = children[x].attrListeners()[listeners][attr],                                    parentLen = parents.length;                                for (var i = 0; i < parentLen; i++) {                                    if (parents[i].isEqualNode(this)) {                                        parents.slice(i, 1);                                    }                                }                            }                        }                    } else {                        if (isStyle) {                            listeners = (update ? '_styleUpdateListeners' : '_styleListeners');                            cut(attr, this.attrListeners()[listeners]);                        } else {                            if (attr === _all) {                                listeners = (update ? '_styleUpdateListeners' : '_styleListeners');                                cut(attr, this.attrListeners()[listeners]);                            }                            listeners = (update ? '_attrUpdateListeners' : '_attrListeners');                            cut(attr, this.attrListeners()[listeners]);                        }                    }                } else {                    if (isStyle) {                        listeners = (update ? _styleUpdateListeners : _styleListeners);                        cut(attr, listeners);                    } else {                        if (attr === _all) {                            listeners = (update ? _styleUpdateListeners : _styleListeners);                            cut(attr, listeners);                        }                        listeners = (update ? _attrUpdateListeners : _attrListeners);                        cut(attr, listeners);                    }                }            }            /* this method gets attached to all elements for easy listener adding of child events */            function addChildAttrListener(attr, func) {                bind.addAttrListener.call(this, attr, func, true);                return this;            }            /* this method gets attached to all elements for easy listener adding of child update events */            function addChildAttrUpdateListener(attr, func) {                bind.addAttrUpdateListener.call(this, attr, func, true);                return this;            }            /* this method gets attached to all elements for easy listener removal of child events */            function removeChildAttrListener(attr, func) {                bind.removeAttrListener.call(this, attr, func, true);                return this;            }            /* this method gets attached to all elements for easy listener removal of child update events */            function removeChildAttrUpdateListener(attr, func) {                bind.removeAttrUpdateListener.call(this, attr, func, true);                return this;            }            /* This method checks if a listener of this function already exists on a desired attribute */            function hasListener(listener, attr, func) {                var _listeners = this.attrListeners();                if (attr === 'html') attr = 'innerHTML';                if (attr === 'events') attr = 'onclick';                switch (listener) {                    case 'attr':                        if (typeof _listeners._attrListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._attrListeners[attr], func)) return true;                        } else if (typeof _listeners._styleListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._styleListeners[attr], func)) return true;                        } else if (typeof _listeners._parentAttrListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._parentAttrListeners[attr], func)) return true;                        } else if (typeof _listeners._parentStyleListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._parentStyleListeners[attr], func)) return true;                        }                        break;                    case 'attrupdate':                        if (typeof _listeners._attrUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._attrUpdateListeners[attr], func)) return true;                        } else if (typeof _listeners._styleUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._styleUpdateListeners[attr], func)) return true;                        } else if (typeof _listeners._parentAttrUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._parentAttrUpdateListeners[attr], func)) return true;                        } else if (typeof _listeners._parentStyleUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_listeners._parentStyleUpdateListeners[attr], func)) return true;                        }                        break;                }                return false;            }            /* sets stopChange Property for stopping update listeners to fire */            function stopChange() {                this._stopChange = true;                return this;            }            /* This is the master constructor, to be ran only once. */            function bind() {                bind.injectPrototypes(Node, 'Node');                bind.injectPrototypes(Element, 'Element');                bind.injectPrototypes(HTMLElement, 'HTMLElement');                bind.injectPrototypes(HTMLInputElement, 'HTMLInputElement');                bind.injectPrototypes(HTMLTextAreaElement, 'HTMLTextAreaElement');                bind.injectPrototypes(Document, 'Document');                var __set = _set,                    __update = _update;                function hasInput(attrListeners) {                    var attrs = ['value', 'checked'],                        _localListeners = attrListeners,                        _localAttr = _localListeners._attrListeners,                        _localUpdateAttr = _localListeners._attrUpdateListeners,                        _localParentAttr = _localListeners._parentAttrListeners,                        _localParentUpdateAttr = _localListeners._parentAttrUpdateListeners,                        has = false;                    if (_attrListeners[_all] !== undefined || _attrUpdateListeners[_all] !== undefined) {                        has = true;                    }                    if (has !== true && _localAttr[_all] !== undefined ||                        _localUpdateAttr[_all] !== undefined ||                        _localParentAttr[_all] !== undefined ||                        _localParentUpdateAttr[_all] !== undefined) {                        has = true;                    }                    if (has !== true) {                        for (var x = 0; x < attrs.length; x++) {                            if (_attrListeners[attrs[x]] !== undefined ||                                _attrUpdateListeners[attrs[x]] !== undefined ||                                _localAttr[attrs[x]] !== undefined ||                                _localUpdateAttr[attrs[x]] !== undefined ||                                _localParentAttr[attrs[x]] !== undefined ||                                _localParentUpdateAttr[attrs[x]] !== undefined) {                                has = true;                                break;                            }                        }                    }                    return has;                }                function getStyles(arr, styles) {                    var x,                        _arr = arr,                        _styles = styles,                        len = styles.length;                    for (x = 0; x < len; x++) {                        if (_arr.indexOf(_styles[x]) === -1) {                            _arr.push(_styles[x]);                        }                    }                    return _arr;                }                function hasStyle(attrListeners) {                    var _globalStyle = Object.keys(_styleListeners),                        _globalStyleUpdate = Object.keys(_styleUpdateListeners),                        _localListeners = attrListeners,                        _localStyle = Object.keys(_localListeners._styleListeners),                        _localUpdateStyle = Object.keys(_localListeners._styleUpdateListeners),                        _localParentStyle = Object.keys(_localListeners._parentStyleListeners),                        _localParentUpdateStyle = Object.keys(_localListeners._parentStyleUpdateListeners),                        has = [];                    if (_globalStyle.length !== 0 ||                        _globalStyleUpdate.length !== 0) {                        has = getStyles(has, _globalStyle);                        has = getStyles(has, _globalStyleUpdate);                    }                    if (has.length !== 0 && _localParentStyle.length !== 0 ||                        _localParentUpdateStyle.length !== 0) {                        has = getStyles(has, _localParentStyle);                        has = getStyles(has, _localParentUpdateStyle);                    }                    if (has.indexOf(_all) !== -1) has = _allStyles;                    return has;                }                function copyListeners(listeners, copyTo) {                    var listenerProps = Object.keys(listeners),                        _currProp,                        _currListener;                    for (var x = 0, len = listenerProps.length; x < len; x++) {                        _currProp = listenerProps[x];                        if (copyTo[_currProp] === undefined) {                            copyTo[_currProp] = listeners[_currProp].slice();                        } else {                            for (var i = 0, lenI = listeners[_currProp].length; i < lenI; i++) {                                _currListener = listeners[_currProp][i];                                copyTo[_currProp].push(_currListener);                            }                        }                    }                }                function reSync(e) {                    if (e.target.nodeType !== 3 && e.target.nodeType !== 8) {                        var attrListeners = e.target.attrListeners(),                            _hasInput = hasInput(attrListeners),                            _hasStyle = hasStyle(attrListeners),                            _hasStyleLen = _hasStyle.length,                            _parentAttr,                            _parentAttrUpdate,                            _parentStyle,                            _parentStyleUpdate,                            _listeners,                            nodes = [],                            len,                            outer = ((e.attr === 'outerHTML' || e.attr === 'outerText') ? e.attr : undefined),                            target = e.target                        if (outer !== undefined) {                            e.attr = 'appendChild',                                e.arguments = [e.target];                            e.target = e.target.parentElement;                        }                        if (_hasInput) {                            if (e.attr === 'appendChild' && e.arguments[0].nodeType !== 3 && e.arguments[0].nodeType !== 8) {                                nodes = Array.prototype.slice.call(e.arguments[0].querySelectorAll('input,textarea'));                                if (e.arguments[0].tagName === 'INPUT' || e.arguments[0].tagName === 'TEXTAREA') {                                    nodes.unshift(e.arguments[0])                                }                            } else {                                nodes = Array.prototype.slice.call(e.target.querySelectorAll('input,textarea'));                            }                            len = nodes.length;                            for (var x = 0; x < len; x++) {                                if (nodes[x].addInputBinding !== undefined) nodes[x].addInputBinding();                                if (nodes[x].addInputBoxBinding !== undefined) nodes[x].addInputBoxBinding();                            }                        }                        if (e.attr === 'appendChild' && e.arguments[0].nodeName !== '#text' && e.arguments[0].nodeName !== '#comment') {                            nodes = Array.prototype.slice.call(e.arguments[0].querySelectorAll('*'));                            nodes.unshift(e.arguments[0]);                            _parentAttr = e.target.__kb._parentAttrListeners;                            _parentAttrUpdate = e.target.__kb._parentAttrUpdateListeners;                            _parentStyle = e.target.__kb._parentStyleListeners;                            _parentStyleUpdate = e.target.__kb._parentStyleUpdateListeners;                        } else {                            nodes = Array.prototype.slice.call(e.target.querySelectorAll('*'));                            _parentAttr = e.target.__kb._parentAttrListeners;                            _parentAttrUpdate = e.target.__kb._parentAttrUpdateListeners;                            _parentStyle = e.target.__kb._parentStyleListeners;                            _parentStyleUpdate = e.target.__kb._parentStyleUpdateListeners;                        }                        len = nodes.length;                        for (var x = 0; x < len; x++) {                            if (_hasStyleLen !== 0) {                                for (var i = 0; i < _hasStyleLen; i++) {                                    bind.injectStyleProperty(nodes[x], _hasStyle[i]);                                }                            }                            _listeners = nodes[x].attrListeners();                            copyListeners(_parentAttr, _listeners._parentAttrListeners);                            copyListeners(_parentAttrUpdate, _listeners._parentAttrUpdateListeners);                            copyListeners(_parentStyle, _listeners._parentStyleListeners);                            copyListeners(_parentStyleUpdate, _listeners._parentStyleUpdateListeners);                        }                        if (outer !== undefined) {                            e.attr = outer;                            e.target = target;                            e.arguments = [];                        }                    }                }                function checkAttr(e) {                    var oldAttr = e.target.attributes[e.arguments[0]],                        old = (oldAttr !== undefined ? oldAttr.value : ""),                        val = (e.attr === 'setAttribute' ? e.arguments[1] : "");                    if (!__set(e.target, e.arguments[0], val, old, [val])) {                        e.preventDefault();                    }                }                function checkAttrUpdate(e) {                    var oldAttr = e.target.attributes[e.arguments[0]],                        old = (oldAttr !== undefined ? oldAttr.value : ""),                        val = (e.attr === 'setAttribute' ? e.arguments[1] : "");                    __update(e.target, e.arguments[0], val, old, [val]);                }                //for keeping binds with inputs                bind.addAttrUpdateListener('appendChild', reSync);                bind.addAttrUpdateListener('removeChild', reSync);                bind.addAttrUpdateListener('innerHTML', reSync);                bind.addAttrUpdateListener('outerHTML', reSync);                bind.addAttrUpdateListener('innerText', reSync);                bind.addAttrUpdateListener('outerText', reSync);                bind.addAttrUpdateListener('textContent', reSync);                //allows for html attribute changes to be listened to just like properties                bind.addAttrListener('setAttribute', checkAttr);                bind.addAttrListener('removeAttribute', checkAttr);                bind.addAttrUpdateListener('setAttribute', checkAttrUpdate);                bind.addAttrUpdateListener('removeAttribute', checkAttrUpdate);                return bind;            }            bind.injectPrototypeProperty = function(obj, key, injectName, set, update) {                var _proto = obj.prototype,                    _descriptor = Object.getOwnPropertyDescriptor(_proto, key),                    _injectName = (injectName || obj.toString().split(/\s+/)[1].split('{')[0].replace('()', '')),                    _injectedObj = _injected[_injectName],                    __set = (set || _set),                    __update = (update || _update);                if (_proto.attrListeners === undefined) {                    _proto = {};                    _proto.attrListeners = (function() {                        if (this.__kb === undefined) {                            this.__kb = new _localBinders();                        }                        return this.__kb;                    }).bind(_proto);                    _proto.addAttrListener = bind.addAttrListener;                    _proto.addAttrUpdateListener = bind.addAttrUpdateListener;                    _proto.addChildAttrListener = addChildAttrListener;                    _proto.addChildAttrUpdateListener = addChildAttrUpdateListener;                    _proto.hasListener = hasListener;                    _proto.removeAttrListener = bind.removeAttrListener;                    _proto.removeAttrUpdateListener = bind.removeAttrUpdateListener;                    _proto.removeChildAttrListener = removeChildAttrListener;                    _proto.removeChildAttrUpdateListener = removeChildAttrUpdateListener;                    _proto.stopChange = stopChange;                }                if (_injectedObj === undefined) {                    _injected[_injectName] = {                        obj: obj,                        proto: _proto,                        descriptors: {},                        set: undefined,                        update: undefined                    };                    _injectedObj = _injected[_injectName];                    _injectedObj.set = __set;                    _injectedObj.update = __update;                }                if (_injectedObj.descriptors[key] === undefined) _injectedObj.descriptors[key] = _descriptor;                if (_descriptor.configurable) {                    if (_descriptor.set !== undefined) {                        Object.defineProperty(_proto, key, {                            get: _descriptor.get,                            set: setStandard(_descriptor, key, __set, __update),                            enumerable: true,                            configurable: true                        });                    } else if (typeof _descriptor.value === 'function') {                        Object.defineProperty(_proto, key, {                            value: setFunction(_descriptor, key, __set, __update),                            writable: true,                            enumerable: true,                            configurable: true                        });                    } else if (_descriptor.value !== undefined) {                        Object.defineProperty(_proto, key, {                            get: function() {                                return _descriptor.value;                            },                            set: setValue(_descriptor, key, __set, __update),                            enumerable: true,                            configurable: true                        });                    }                }                return bind;            }            bind.injectStyleProperty = function(el, key, set, update) {                var _proto = el.style,                    _descriptor = Object.getOwnPropertyDescriptor(_proto, key),                    _injectedObj = el.attrListeners().injectedStyle,                    __set = (set || _set),                    __update = (update || _update);                if (_injectedObj === undefined) {                    el.attrListeners().injectedStyle = {                        obj: el,                        proto: _proto,                        descriptors: {},                        set: undefined,                        update: undefined                    };                    el.attrListeners().injectedStyle.set = __set;                    el.attrListeners().injectedStyle.update = __update;                    _injectedObj = el.attrListeners().injectedStyle;                }                if (_injectedObj.descriptors[key] === undefined) _injectedObj.descriptors[key] = _descriptor;                if (_descriptor.configurable) {                    Object.defineProperty(_proto, key, setStyle(_descriptor, key, __set, __update, el));                }                return bind;            }            bind.injectPrototypes = function(obj, injectName, set, update) {                var _proto = obj.prototype,                    _injectName = (injectName || obj.toString().split(/\s+/)[1].split('{')[0].replace('()', '')),                    _injectedObj = _injected[_injectName],                    _keys = Object.getOwnPropertyNames(_proto),                    __set = (set || _set),                    __update = (update || _update),                    _descriptors,                    x;                if (_proto.attrListeners === undefined) {                    _proto.attrListeners = function() {                        if (this.__kb === undefined) {                            this.__kb = new _localBinders();                        }                        return this.__kb;                    }                    _proto.addAttrListener = bind.addAttrListener;                    _proto.addAttrUpdateListener = bind.addAttrUpdateListener;                    _proto.addChildAttrListener = addChildAttrListener;                    _proto.addChildAttrUpdateListener = addChildAttrUpdateListener;                    _proto.removeAttrListener = bind.removeAttrListener;                    _proto.removeAttrUpdateListener = bind.removeAttrUpdateListener;                    _proto.removeChildAttrListener = removeChildAttrListener;                    _proto.removeChildAttrUpdateListener = removeChildAttrUpdateListener;                    _proto.hasListener = hasListener;                    _proto.stopChange = stopChange;                }                if (_injectedObj === undefined) {                    _injected[_injectName] = {                        obj: obj,                        proto: _proto,                        descriptors: {},                        set: undefined,                        update: undefined                    };                    _injectedObj = _injected[_injectName];                    _injectedObj.set = __set;                    _injectedObj.update = __update;                }                _descriptors = _injected[_injectName].descriptors;                for (x = 0; x < _keys.length; x += 1) {                    if (_descriptors[_keys[x]] === undefined) {                        bind.injectPrototypeProperty(obj, _keys[x], _injectName, __set, _update);                    }                }                if (_keys.indexOf('value') !== -1) {                    function keyDown(e) {                        var isCheck,                            oldCheck,                            oldValue,                            value;                        if (this.type === 'checkbox' || this.type === 'radio') {                            oldCheck = this.checked;                            isCheck = true;                        }                        oldValue = (isCheck ? (typeof this.checked === 'string' ? this.checked : (this.checked ? "true" : "false")) : this.value);                        setTimeout((function() {                            value = (isCheck ? (typeof this.checked === 'string' ? this.checked : (this.checked ? "true" : "false")) : this.value);                            if (isCheck) {                                if (!_injectedObj.set(this, 'checked', this.checked, oldValue)) {                                    _descriptors['checked'].set.call(this, oldValue);                                } else {                                    _injectedObj.update(this, 'checked', this.checked, oldValue);                                }                            }                            if (this.value !== value) this.value = value;                            if (!_injectedObj.set(this, 'value', this.value, oldValue)) {                                _descriptors['value'].set.call(this, oldValue);                            } else {                                _injectedObj.update(this, 'value', this.value, oldValue);                            }                        }).bind(this), 0);                    }                    _proto.removeInputBinding = function() {                        this.attrListeners()._onkeydown = undefined;                        this.removeEventListener('keydown', keyDown);                    }                    _proto.addInputBinding = function() {                        this.attrListeners()._onkeydown = true;                        this.addEventListener('keydown', keyDown);                    }                    _proto.removeInputBoxBinding = function() {                        this.attrListeners()._onmousedown = undefined;                        this.removeEventListener('mouseup', keyDown);                    }                    _proto.addInputBoxBinding = function() {                        this.attrListeners()._onmousedown = true;                        this.addEventListener('mouseup', keyDown);                    }                }                return bind;            }            bind.addAttrListener = function(attr, func, child) {                if (attr === 'html') {                    for (var x = 0, len = _texts.length; x < len; x++) {                        addListener.call(this, _texts[x], func, child, false);                    }                } else if (attr === 'events') {                    for (var x = 0, len = _allEvents.length; x < len; x++) {                        addListener.call(this, _allEvents[x], func, child, false);                    }                } else {                    addListener.call(this, attr, func, child, false);                }                return this;            }            bind.addAttrUpdateListener = function(attr, func, child) {                if (attr === 'html') {                    for (var x = 0, len = _texts.length; x < len; x++) {                        addListener.call(this, _texts[x], func, child, true);                    }                } else if (attr === 'events') {                    for (var x = 0, len = _allEvents.length; x < len; x++) {                        addListener.call(this, _allEvents[x], func, child, true);                    }                } else {                    addListener.call(this, attr, func, child, true);                }                return this;            }            bind.removeAttrListener = function(attr, func, child) {                if (attr === 'html') {                    for (var x = 0, len = _texts.length; x < len; x++) {                        removeListener.call(this, _texts[x], func, child, false);                    }                } else if (attr === 'events') {                    for (var x = 0, len = _allEvents.length; x < len; x++) {                        removeListener.call(this, _allEvents[x], func, child, false);                    }                } else {                    removeListener.call(this, attr, func, child, false);                }                return this;            }            bind.removeAttrUpdateListener = function(attr, func, child) {                if (attr === 'html') {                    for (var x = 0, len = _texts.length; x < len; x++) {                        removeListener.call(this, _texts[x], func, child, true);                    }                } else if (attr === 'events') {                    for (var x = 0, len = _allEvents.length; x < len; x++) {                        removeListener.call(this, _allEvents[x], func, child, true);                    }                } else {                    removeListener.call(this, attr, func, child, true);                }                return this;            }            bind.hasListener = function(listener, attr, func) {                if (attr === 'html') attr = 'innerHTML';                if (attr === 'events') attr = 'onclick';                switch (listener) {                    case 'attr':                        if (typeof _attrListeners[attr] !== undefined) {                            if (loopListenerCheck(_attrListeners[attr], func)) return true;                        } else if (typeof _styleListeners[attr] !== undefined) {                            if (loopListenerCheck(_styleListeners[attr], func)) return true;                        }                        break;                    case 'attrupdate':                        if (typeof _attrUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_attrUpdateListeners[attr], func)) return true;                        } else if (typeof _styleUpdateListeners[attr] !== undefined) {                            if (loopListenerCheck(_styleUpdateListeners[attr], func)) return true;                        }                        break;                }                return false;            }            bind.injectedPrototypes = function() {                return _injected;            }            return bind;        }        if (typeof define === "function" && define.amd) {            define('KB', CreateKB); //global KM define in browser        }        return CreateKB;    }())    var CreateKonnektMP = (function(kb) {        function CreateKonnektMP() {            var _start = "{{",                _end = "}}",                _pipe = "|",                /* where all templates are stored */                _templates = {},                /* Regex for nodes in a string, eg: str.match(_reNodes) returns all node names in string */                _reNodes = /(<\/.*?>)/g,                /* KB watch engine used for dom listening */                _kb = kb().call(),                /* All dom based events such as onclick */                _domevents = Object.keys(HTMLElement.prototype).filter(function(v) {                    return v.indexOf('on') === 0                }).concat(['ontouchstart', 'ontouchend', 'ontouchmove']),                _events = {                    loopitem: [],                    replaceNode: []                },                _onEvent = function(e) {                    var _listeners = _events[e.event];                    for (var x = 0, len = _listeners.length; x < len; x++) {                        _listeners[x](e);                    }                }            function KonnektMP(node) {                var _fragment = document.createDocumentFragment();                /* Name of the component */                this.name = node.tagName.toLowerCase();                /* template of the component */                this.template = _templates[this.name] || '<div class="missing_component">Unknown Component</div>';                /* original node */                this.node = node;                /* document fragment to prevent reflow for faster browser rendering */                this.fragment = document.createDocumentFragment();                /* wrapper div for placing components inside */                this.wrapper = this.fragment.appendChild(document.createElement('div'));                /* set wrapper html and define class */                this.wrapper.className = "Wrapper Wrapper__" + this.name;                if (this.template.match(getNodeMatch())) {                    this.template = getEnclosedNodes(this.template);                }            }            KonnektMP.start = function(v) {                if (v === undefined) return _start;                _start = (typeof v === 'string' ? v : _start);                return KonnektMP;            }            KonnektMP.end = function(v) {                if (v === undefined) return _end;                _end = (typeof v === 'string' ? v : _end);                return KonnektMP;            }            KonnektMP.pipe = function(v) {                if (v === undefined) return _pipe;                _pipe = (typeof v === 'string' ? v : _pipe);                return KonnektMP;            }            /* filters out names of unregistered elements from a template string */            KonnektMP.getUnknown = function(template) {                /* run regex match on all </end tags> */                var matched = template.match(_reNodes)                    .map(function(k) {                        /* remove '</' and '>' chars from string to leave just the name of the node */                        return k.replace(/[<\/>]/g, "");                    });                matched.filter(function(k, i) {                    /* filter out default elements and duplicates as well as components that are already registered */                    return (k.indexOf(_start) !== 0 && (document.createElement(k) instanceof HTMLUnknownElement) && (matched.indexOf(k, (i + 1)) === -1) && _templates[k] === undefined);                });                /* if there are unregistered components run global event for registration */                //if(matched.length !== 0) onEvent('unknown',new Event('unknown',matched));                return matched;            }            /* checks if a component name has been defined */            KonnektMP.isRegistered = function(name) {                return (_templates[name] !== undefined);            }            /* registers template to a given name and fires unregistered components event if any are found */            KonnektMP.register = function(name, template) {                if (_templates[name] === undefined) {                    _templates[name] = template;                    /* unregistered components can be loaded via globalized listener on registration */                    KonnektMP.getUnknown(template);                } else {                    console.error("Class: KonnektMP Method: 'register', A template by the name %o already exists", name);                }                return this;            }            /* Event Handlers */            /* adds an event listener with the appropriate key */            KonnektMP.addEventListener = function(key, func) {                if (_events[key] !== undefined) {                    _events[key].push(func);                } else {                    console.error("Class: KonnektMP Method: 'addEventListener', No event exists with the name %o", key);                }                return KonnektMP;            }            /* removes event listener, dependent on key and function being the same */            KonnektMP.removeEventListener = function(key, func) {                if (_events[key] !== undefined) {                    for (var x = 0, len = _events[key].length; x < len; x++) {                        if (_events[key][x].toString() === func.toString()) {                            _events[key].splice(x, 1);                        }                    }                } else {                    console.error("Class: KonnektMP Method: 'removeEventListener', No event exists with the name %o", key);                }                return KonnektMP;            }            /* Descriptors */            function setDescriptor(value, writable, redefinable, enumerable) {                return {                    value: value,                    writable: !!writable,                    enumerable: !!enumerable,                    configurable: !!redefinable                }            }            function setPointer(obj, key, redefinable, enumerable) {                var _desc = Object.getOwnPropertyDescriptor(obj, key);                return {                    get: function() {                        return obj.get(key);                    },                    set: function(v) {                        (this._stopChange ? obj.stopChange() : obj).set(prop, v);                        this._stopChange = false;                    },                    configurable: !!redefinable,                    enumerable: !!enumerable                }            }            /* REGEX Map Splitters */            /* Returns a regex that matches against map bindings based on start and end chars */            function getMatch() {                return new RegExp('(\\' + _start.split('').join('\\') + ')(.*?)(\\' + _end.split('').join('\\') + ')', 'g')            }            /* Returns a regex that matches against formap bindings based on start and end chars */            function getForMatch() {                return new RegExp('(\\' + _start.split('').join('\\') + ')(.*?)(for)(.*?)(loop)(.*?)(\\' + _end.split('').join('\\') + ')', 'g');            }            function getNodeMatch() {                return new RegExp('(<\\' + _start.split('').join('\\') + '.*?\\' + _end.split('').join('\\') + '.*?>|' + '<\\/\\' + _start.split('').join('\\') + '.*?\\' + _end.split('').join('\\') + '>)');            }            function getEnclosedNodes(html) {                var reg = getNodeMatch(),                    split = html.split(reg).filter(Boolean),                    splitdexes = {};                for (var x = 0, key, keys, replaceKey, len = split.length; x < len; x++) {                    if (split[x].match(reg)) {                        key = splitKey(split[x].substring(split[x].indexOf('<'), split[x].indexOf('}}')) + "}").replace(/[<>]/g, '');                        if (key.indexOf('/') === 0 && splitdexes[key.replace('/', '')]) {                            key = key.replace('/', '');                            keys = Object.keys(splitdexes[key], 'array');                            if (keys.length !== 0) {                                replaceKey = keys[(keys.length - 1)];                                split[replaceKey] = '<!--' + split[replaceKey];                                splitdexes[key].splice(parseInt(replaceKey, 10), 1);                                split[x] = split[x] + '-->';                                keys = Object.keys(splitdexes[key], 'array');                                if (keys.length === 0) {                                    splitdexes[key] = null;                                    delete splitdexes[key];                                }                            }                        } else {                            if (!splitdexes[key]) splitdexes[key] = [];                            splitdexes[key][x] = split[x];                        }                    }                }                for (var x = 0, keys = Object.keys(splitdexes), len = keys.length; x < len; x++) {                    for (var i = 0, keysI = Object.keys(splitdexes[keys[x]], 'array'), lenn = keysI.length; x < len; x++) {                        split[keysI[i]] = '<!--' + split[keysI[i]] + '-->';                    }                }                return split.join('');            }            /* returns an array of standard text and bindings, binding texts are later converted to bind objects               EXAMPLE::                string: "Hello {{name}}, {{greeting}}"                return: ["Hello ", "{{name}}", ", ", "{{greeting}}"]            */            function splitText(s) {                /* splits the string by _start and _end: ["Hello ","{{","name","}}",", ","{{","greeting","}}"] */                return s.split(new RegExp('(' + _start.split('').join('\\') + ')(.*?)(' + _end.split('').join('\\') + ')', 'g'))                    /* remaps values to have the _start and _end brackets: ["Hello ","{{","{{name}}","}}",", ","{{","{{greeting}}","}}"]*/                    .map(function(v, i, arr) {                        return ((arr[(i - 1)] === _start) ? (_start + v + _end) : v);                    })                    /* filter out single _start and _end entries: ["Hello ","{{name}}",", ","{{greeting}}"]*/                    .filter(function(v, i, arr) {                        return (v.length !== 0 && v !== _start && v !== _end && v.length !== 0);                    });            }            /* returns an array of standard bind names               EXAMPLE::                splitText: ["Hello ", "{{name}}", ", ", "{{greeting}}"]                return: ["name","greeting"]            */            function splitBindNames(splitTexts) {                /* filter out all non bind strings: ["{{name}}","{{greeting}}"]*/                return splitTexts.filter(function(v) {                        return (v.indexOf(_start) !== -1 && v.indexOf(_end) !== -1);                    })                    /* modify string to standard key names: ["name","greeting"]*/                    .map(function(v) {                        return splitKey(v);                    });            }            /* takes a bind and returns just the name/key               EXAMPLE::                string: "{{name | toUpperCase}}"                return: "name"            */            function splitKey(b) {                /* removes _start and _end from the string: "name | toUpperCase" */                return b.replace(new RegExp('[' + _start + _end + ']', 'g'), '')                    /* removes pipe and all that follows: "name "*/                    .replace(new RegExp('(\\' + _pipe.split('').join('\\') + '(.*?)+)', 'g'), '').replace(/\s/g, '');            }            /* takes a bind and returns array of the filter names               EXAMPLE::                string: "{{name | toUpperCase, duplicate}}"                return: ["toUpperCase","duplicate"]            */            function splitFilters(b) {                if (b.indexOf(_pipe) !== -1) {                    /* remove _end characters from string: "{{name | toUpperCase, duplicate"  */                    return b.replace(new RegExp('[' + _end + ']', 'g'), '')                        /* removes everything before the _pipe characters: " toUpperCase, duplicate"*/                        .replace(new RegExp('(.*?)(\\' + _pipe.split('').join('\\') + ')'), '')                        /* removes all spaces "toUpperCase,duplicate"*/                        .replace(/\s/g, '')                        /* splits into array nased on ',': ["toUpperCase","duplicate"] */                        .split(',');                }                return [];            }            /* takes a filters array and parses out specials, eg: (vmFilter),[(~|+|-)storename]               EXAMPLE::                string: "["toUpperCase","(duplicate)","[~model.key]"]"                return: {filters:["toUpperCase"],vmFilters:["duplicate"],model:["model.key"],local:[],session:[]}            */            function sortFilters(f) {                return f.reduce(function(obj, filter) {                    if (filter.match(/(\()(.*?)(\))/)) {                        obj.vmFilters[obj.vmFilters.length] = filter.replace(/[\(\)]/g, '');                    } else if (filter.match(/(\[)(.*?)(\])/)) {                        if (filter.indexOf('~') !== -1) {                            obj.model[obj.model.length] = filter.replace(/[\[\]\~]/g, '');                        } else if (filter.indexOf('+') !== -1) {                            obj.local[obj.local.length] = filter.replace(/[\[\]\+]/g, '');                        } else {                            obj.session[obj.session.length] = filter.replace(/[\[\]\-]/g, '');                        }                    } else {                        obj.filters[obj.filters.length] = filter;                    }                    return obj;                }, {                    filters: [],                    vmFilters: [],                    model: [],                    local: [],                    session: []                });            }            /* takes a for bind and returns array of key and component               EXAMPLE::                string: "{{for items loop listitem | hasName}}"                return: ["items","listitem"]            */            function splitFor(b) {                if (b.indexOf('for') !== -1) {                    /* removes _start and _end characters: "for items loop listitem | hasName" */                    return b.replace(new RegExp('[' + _start + _end + ']', 'g'), '')                        /* removes pipe and all text after it: "for items loop listitem "*/                        .replace(new RegExp('\\' + '|'.split('').join('\\') + '(.*)'), '')                        /* removes all empty spaces:  "foritemslooplistitem"*/                        .replace(/\s/g, '')                        /* splits the string removing 'for' and 'loop' leaving only key and component in an array: ["items","listitem"]*/                        .split(/for(.*?)loop/)                        /* in case any trailing empty strings are in array */                        .filter(function(v) {                            return v.length !== 0;                        });                }                return [];            }            function getSet(key) {                if (key.split('==').length < 2 && key.split('<=').length < 2 && key.split('>=').length < 2 && key.indexOf('=') !== -1) {                    return key.substring((key.indexOf('=') + 1), key.length);                }                return undefined;            }            /* Parses a key to look for subTypes and included filters               >key = insert               <key=val = outsert               key=val = setbind               key(==|>|<|>=|<=)val = filter               key(+|-|*|/)val = filter               EXAMPLE::                string: "{{ >key }}"                return: {sub:'insert'}            */            function parseKey(key) {                var isInsert = key.match(/^(\s*)(>)((.*?)+)/),                    isOutsert = key.match(/^(\s*)(<)((.*?)+)/);                key = key.replace(/(^<|^>)((.*?)+)/, '$2');                var set = getSet(key),                    boolFilter = key.match(/((==|<=|>=|<|>)((.*?)+))/g),                    mathFilter = key.match(/(([\+\*-\/])((.*?)+))/g);                return {                    type: (isInsert ? 'insert' : (isOutsert ? 'outsert' : undefined)),                    set: (set !== key ? set : undefined),                    filters: (boolFilter || mathFilter ? {                        boolFilter: (boolFilter ? eval("(function(){ return function(v){ return (v" + boolFilter[0] + ");};}())") : undefined),                        mathFilter: (mathFilter ? eval("(function(){ return function(v){ return (v" + mathFilter[0] + ");};}())") : undefined)                    } : undefined)                };            }            /* Helpers */            function runThroughBinds(binds) {                if (binds.length !== 0) {                    var text = '';                    for (var x = 0, len = binds.length; x < len; x++) {                        if (typeof binds[x] === 'string') {                            text += binds[x];                        } else {                            if (binds[x]._data === undefined) {                                text += binds[x].text;                            } else {                                var val = binds[x]._data.get(binds[x].key);                                text += runThroughFilters((val !== undefined ? val : ''), binds[x].filters.filters, binds[x]._data.filters);                            }                        }                    }                    return text;                } else {                    return runThroughFilters(binds[0]._data.get(binds[0].key) || '', binds[0].filters.filters, binds[0]._data.filters);                }            }            function runThroughFilters(val, filters, filterFuncs) {                for (var x = 0, len = filters.length; x < len; x++) {                    if (filterFuncs[filters[x]]) val = filterFuncs[filters[x]](val);                }                return val;            }            function runThroughForFilters(data, filters, filterFuncs, index) {                for (var x = 0, len = filters.length; x < len; x++) {                    if (filterFuncs[filters[x]]) filterFuncs[filters[x]](data, index);                }                return data;            }            function runThroughComponentFilters(value, filters, filterFunc) {                for (var x = 0, len = filters.length; x < len; x++) {                    if (filterFuncs[filters[x]]) value = filterFuncs[filters[x]](data, index);                }                return value;            }            /* Prototyped Methods */            /* need better methods to approach adding and swapping filters for bindings */            function map(node) {                function loopMap(childNodes, binds) {                    for (var x = 0, len = childNodes.length; x < len; x++) {                        if (childNodes[x].kb_maps === undefined && childNodes[x].nodeType !== 8) {                            /* add mapper refrence so from any node we can always go back to root */                            childNodes[x].kb_mapper = node;                            childNodes[x].kb_maps = binds;                            /* check if node is a text node */                            if (childNodes[x].nodeType === 3) {                                getTextBinds(childNodes[x], binds);                            }                            /* if it isnt then only check attributes for binds */                            else {                                getAttrBinds(childNodes[x], binds);                            }                            /* if this childnode has other children nodes then we run recursive */                            if (childNodes[x].childNodes && childNodes[x].childNodes.length !== 0) {                                binds = loopMap(childNodes[x].childNodes, binds);                            }                        } else if (childNodes[x].nodeType === 8) {                            getNodeBinds(childNodes[x], binds);                        }                    }                    return binds;                }                return loopMap(node.childNodes, {});            }            function getTextBinds(node, binds) {                /* the actual text */                var text = node.textContent;                /* matches an array of _start and end looking for binds in the text */                if (text.match(getMatch())) {                    var bindText = splitText(text),                        binder = CreateBind();                    binder.prototype.type = (text.match(getForMatch()) ? 'for' : 'text');                    binder.prototype.text = text;                    binder.prototype.bindText = bindText;                    binder.prototype.listener = 'textContent';                    binder.prototype.attr = 'textContent';                    binder.prototype.localAttr = 'textContent';                    binder.prototype.local = node;                    binder.prototype.node = node.parentElement;                    binder.prototype.binds = binds;                    for (var x = 0, len = bindText.length; x < len; x++) {                        /* if this is a bind */                        if (bindText[x].indexOf(_start) === 0) {                            var key = (binder.prototype.type === 'for' ? splitFor(bindText[x])[0] : splitKey(bindText[x])),                                bind = new binder(bindText[x], key);                            /* create new bind object and attach to the binds list for returning */                            if (binds[key] === undefined) binds[key] = [];                            bind.bindText[x] = bind;                            bind.bindMaps.push(bind);                            bind.id = binds[key].length;                            binds[key].push(bind);                        }                    }                }            }            function getAttrBinds(node, binds) {                /* all attributes of the node */                var attrs = Array.prototype.slice.call(node.attributes),                    /* if the parent element is a component then we need to treat it as a single instance map */                    isUnknown = (node instanceof HTMLUnknownElement);                for (var i = 0, lenn = attrs.length; i < lenn; i++) {                    if (attrs[i].value.match(getMatch())) {                        /*specifies bind type: component|attribute */                        var bindText = splitText(attrs[i].value),                            binder = CreateBind()                        binder.prototype.type = (isUnknown ? 'component' : 'attribute');                        binder.prototype.text = attrs[i].value;                        binder.prototype.bindText = bindText;                        binder.prototype.isEvent = (_domevents.indexOf(attrs[i].name) !== -1);                        binder.prototype.isInput = (node.tagName.toLowerCase() === 'input');                        binder.prototype.isRadio = (binder.prototype.isInput ? (['radio', 'checkbox'].indexOf(node.type) !== -1) : false);                        binder.prototype.listener = attrs[i].name;                        binder.prototype.attr = attrs[i].name;                        binder.prototype.localAttr = 'value';                        binder.prototype.local = attrs[i];                        binder.prototype.node = node;                        binder.prototype.binds = binds;                        if (binder.prototype.isEvent) {                            node.removeAttribute(attrs[i].name);                        }                        for (var x = 0, len = bindText.length; x < len; x++) {                            /* if this is a bind */                            if (bindText[x].indexOf(_start) === 0) {                                var key = splitKey(bindText[x]),                                    bind = new binder(bindText[x], key);                                /* create new bind object and attach to the binds list for returning */                                if (binds[key] === undefined) binds[key] = [];                                bind.bindText[x] = bind;                                bind.bindMaps.push(bind);                                bind.id = binds[key].length;                                binds[key].push(bind);                            }                        }                    }                }            }            function getNodeBinds(node, binds) {                /* the actual text */                var text = node.textContent;                if (text.match(getNodeMatch())) {                    var bindText = splitText(text),                        binder = CreateBind();                    binder.prototype.type = 'node';                    binder.prototype.text = text;                    binder.prototype.bindText = bindText;                    binder.prototype.base = bindText[1];                    binder.prototype.listener = 'textContent';                    binder.prototype.attr = 'textContent';                    binder.prototype.localAttr = 'textContent';                    binder.prototype.local = node;                    binder.prototype.node = node.parentElement;                    binder.prototype.binds = binds;                    binder.prototype.replacement = undefined;                    for (var x = 0, len = bindText.length; x < len; x++) {                        if (bindText[x].indexOf(_start) === 0) {                            var key = splitKey(bindText[x]),                                bind = new binder(bindText[x], key);                            /* create new bind object and attach to the binds list for returning */                            if (binds[key] === undefined) binds[key] = [];                            bind.bindText[x] = bind;                            bind.bindMaps.push(bind);                            bind.id = binds[key].length;                            if (x === 1) {                                binder.prototype.base = bind;                                bind.isBase = true;                            }                            binds[key].push(bind);                        }                    }                }            }            Object.defineProperties(KonnektMP.prototype, {                register: setDescriptor(KonnektMP.register),                isRegistered: setDescriptor(KonnektMP.isRegistered),                getUnknown: setDescriptor(KonnektMP.getUnknown),                map: setDescriptor(map)            });            /* Bind object and methods */            function CreateBind() {                function bind(text, key) {                    var parsedKey = parseKey(key);                    this.text = text;                    this.key = key.replace(/(^>|^<*)(.*?)([=*+-\/<>]+)((.*?)+)/g, '$2').replace(/\s/g, '');                    this.keyLength = this.key.split('.').length;                    this.localKey = this.key.split('.').pop();                    this.filters = sortFilters(splitFilters(text));                    this.component = (this.type === 'for' ? splitFor(text)[1] : undefined);                    this.id = 0;                    this.subType = parsedKey.subtype;                    this.set = parsedKey.set;                    this.inlineFilters = parsedKey.filters;                    this.isBase = false;                }                function reconnect() {                    if (this.type !== 'for') {                        this._data.getLayer(this.key).removeDataUpdateListener(this.localKey, this.dataListener);                        if (this.bindText.length === 1) {                            this.node.removeAttrUpdateListener(this.listener, this.domListener);                        }                    } else {                        this._data.getLayer(this.key)                            .removeDataMethodUpdateListener(this.extraListener);                    }                    this.connect(this._data);                    return this;                }                function reset() {                    if (this.type === 'for') {                        this._data.getLayer(this.key)                            .removeDataMethodUpdateListener(this.extraListener)                            .addDataMethodUpdateListener(this.extraListener);                    } else {                        if (this.dataListener) {                            this._data.getLayer(this.key)                                .removeDataUpdateListener(this.localKey, this.dataListener)                                .addDataUpdateListener(this.localKey, this.dataListener);                            if (this.bindText.length === 1) {                                this.node.removeAttrUpdateListener(this.listener, this.domListener)                                    .addAttrUpdateListener(this.listener, this.domListener);                            }                        }                    }                }                function connect(data) {                    var self = this;                    this._data = data;                    if (this.type !== 'for') {                        /* pass filters associated with pointer */                        if (this._data.pointers[this.key] !== undefined && this._data.pointers[this.key].filters !== undefined) {                            var dtfilters = this._data.pointers[this.key].filters.dataFilters;                            for (var x = 0, keys = Object.keys(this._data.pointers[this.key].filters.stringFilters), len = keys.length; x < len; x++) {                                var filters = this._data.pointers[this.key].filters.stringFilters[keys[x]];                                for (var i = 0, lenn = filters.length; i < lenn; i++) {                                    if (this.filters[keys[x]].indexOf(filters[i]) === -1) {                                        this.filters[keys[x]].push(filters[i]);                                        if (['vmfilters', 'filters'].indexOf(keys[x]) !== -1 && dtfilters[filters[i]] !== undefined && this._data.filters[filters[i]] === undefined) {                                            this._data.filters[filters[i]] = dtfilters[filters[i]];                                        }                                    }                                }                            }                        }                        if (this.insert) {                            this.setDom(this._data.get(this.key));                            this.unsync();                            return;                        }                        if (this.set) {                            var isNumber = (!isNaN(parseInt(this.set, 10)) && parseInt(this.set, 10).toString().length === this.set.length),                                isBool = (this.set.replace(/\s/g, '') === 'true' || this.set.replace(/\s/g, '') === 'false'),                                isString = (this.set.indexOf('"') !== -1 || this.set.indexOf("'") !== -1);                            if (isNumber) {                                this.set = parseInt(this.set, 10)                            } else if (isBool) {                                this.set = (this.set.replace(/\s/g, '') === 'true');                            } else if (isString) {                                this.set = this.set.replace(/((\s*\"|\')(.*?)(\"|\'))/g, '$3');                            } else {                                this.set = undefined;                            }                            if (this.set) this._data.set(this.key, this.set);                        }                        if (this.outsert) {                            this.setDom("");                            this.unsync();                            return;                        }                        if (this.inlineFilters) {                            if (this.inlineFilters.boolFilter) {                                this.filters.filters.unshift('boolFilter');                                this._data.filters.boolFilter = this.inlineFilters.boolFilter;                            } else {                                this.filters.filters.unshift('mathFilter');                                this._data.filters.mathFilter = this.inlineFilters.mathFilter;                            }                        }                        if (this.type === 'component') {                            /* first check storage to data */                            if (!!this.filters.model && this.filters.model.length !== 0) {                                this._data.stopChange().set(this.key, getModel(this.filters.model));                            } else if (!!this.filters.session && this.filters.session.length !== 0) {                                this._data.stopChange().set(this.key, getSession(this.filters.session));                            } else if (!!this.filters.local && this.filters.local.length !== 0) {                                this._data.stopChange().set(this.key, getLocal(this.filters.local));                            }                            if (!this.node.k_post) this.node.k_post = {};                            this.node.k_post[this.attr] = {                                filters: {                                    dataFilters: this._data.filters,                                    stringFilters: this.filters                                },                                pointer: this._data.getLayer(this.key),                                key: this.key.split('.').pop()                            };                            return this;                        }                        if (this.type === 'node') {                            if (this.isBase) {                                this.dataListener = function(e) {                                    if (e.event === 'delete') {                                        self.unsync();                                    } else {                                        self.replaceNode();                                    }                                }                                data.getLayer(this.key)                                    .addDataUpdateListener(this.localKey, this.dataListener);                                return this;                            }                            return this;                        }                        this.dataListener = function(e) {                            if (e.event === 'delete') {                                self.unsync();                            } else {                                self.setDom(e.value);                            }                        }                        if (!this.isEvent) data.getLayer(this.key)                            .addDataUpdateListener(this.localKey, this.dataListener);                        if (this.bindText.length === 1 && !this.isEvent) {                            this.domListener = function(e) {                                self.setData(e.value);                            }                            this.node.__kbhtmllistener = true;                            this.node.addAttrUpdateListener(this.listener, this.domListener);                        }                    } else {                        this.dataListener = function(e) {                            if (e.type === 'postset' && (!e.oldValue || (e.oldValue.length === 0))) {                                e.event = 'create';                            }                            self.setLoop(e.key, e.event);                        }                        data.getLayer(this.key)                            .addDataMethodUpdateListener(this.dataListener);                    }                    if (this.type !== 'for') {                        /* first check storage to data */                        if (!!this.filters.model && this.filters.model.length !== 0) {                            this._data.stopChange().set(this.key, getModel(this.filters.model));                        } else if (!!this.filters.session && this.filters.session.length !== 0) {                            this._data.stopChange().set(this.key, getSession(this.filters.session));                        } else if (!!this.filters.local && this.filters.local.length !== 0) {                            this._data.stopChange().set(this.key, getLocal(this.filters.local));                        }                        /* then update dom */                        if (this.isEvent) {                            this.dataListener = function(e) {                                self.node.stopChange().removeEventListener(self.attr.replace('on', ''), e.oldValue);                                self.node.stopChange().addEventListener(self.attr.replace('on', ''), e.value);                            }                            /* need to updae this to use addEventListener */                            this._data.addDataUpdateListener(this.key, this.dataListener);                            this.node.stopChange().addEventListener(this.attr.replace('on', ''), this._data.get(this.key));                        } else if (this.key === 'innerHTML') {                            /* first clear binding text, then append nodes */                            this.node.stopChange().innerHTML = "";                            inserthtml(this.node, this._data.innerHTML);                        } else {                            this.local.stopChange()[this.localAttr] = runThroughBinds(this.bindText);                            if (this.isInput && (['value', 'checked'].indexOf(this.attr) !== -1)) {                                var val = this._data.get(this.key);                                this.node.stopChange()[this.attr] = (val !== undefined ? val : '');                            }                        }                    }                    return this;                }                function inserthtml(node, html) {                    for (var x = 0, len = html.length; x < len; x++) {                        node.stopChange().appendChild(html[x])                    }                }                function getModel(filters) {                    if (!!filters && window.model) {                        return window.model.get(filters[0]);                    }                }                function setModel(value, filters) {                    if (!!filters && filters.length !== 0 && window.model) {                        for (var x = 0, len = filters.length; x < len; x++) {                            window.model.set(filters[x], value);                        }                    }                }                function getLocal(filters) {                    if (!!filters && window.localStorage) {                        return localStorage.getItem(filters[0]);                    }                }                function setLocal(filters, value) {                    if (!!filters && filters.length !== 0 && window.localStorage) {                        for (var x = 0, len = filters.length; x < len; x++) {                            localStorage.setItem(filters[x], value);                        }                    }                }                function getSession(filters) {                    if (!!filters && window.sessionStorage) {                        return sessionStorage.getItem(filters[0]);                    }                }                function setSession(filters, value) {                    if (!!filters && filters.length !== 0 && window.sessionStorage) {                        for (var x = 0, len = filters.length; x < len; x++) {                            sessionStorage.setItem(filters[x], value);                        }                    }                }                function setData(value) {                    /* run through vmFilters + post set storage and model filters */                    value = runThroughFilters(value, this.filters.vmFilters, this._data.filters);                    this._data.stopChange().set(this.key, value);                    setModel(this.filters.model, value);                    setSession(this.filters.session, value);                    setLocal(this.filters.local, value);                    return this;                }                function setDom(value) {                    /* run through Standard filters + pre set storage and model filters */                    setModel(this.filters.model, value);                    setSession(this.filters.session, value);                    setLocal(this.filters.local, value);                    if (this.isEvent) {                        this.node.stopChange()[this.attr] = this._data.get(this.key);                    } else if (this.isInput && (['value', 'checked'].indexOf(this.attr) !== -1)) {                        this.node.stopChange()[this.attr] = this._data.get(this.key);                    } else if (this.key === 'innerHTML') {                        /* first clear binding text, then append nodes */                        this.node.stopChange().innerHTML = "";                        inserthtml(this.node, this._data.innerHTML);                    } else {                        this.local.stopChange()[this.localAttr] = runThroughBinds(this.bindText);                        if (this.isInput && (['value', 'checked'].indexOf(this.attr) !== -1)) {                            var val = this._data.get(this.key);                            this.node.stopChange()[this.attr] = (val !== undefined ? val : '');                        }                    }                    return this;                }                function replaceNode() {                    var frag = document.createDocumentFragment(),                        tempDiv = frag.appendChild(document.createElement('div')),                        localComponent,                        foundEmpty = false,                        self = this;                    tempDiv.innerHTML = this.bindText.map(function(bind, x) {                        if (typeof bind === 'object') {                            if (bind._data === undefined) {                                foundEmpty = true;                                return '';                            }                            if (bind.key === self.bindText[1].key) {                                var val = runThroughFilters(bind._data.get(bind.key), bind.filters, bind._data.filters) || 'unknown';                                if (val === 'unkown' && x === 1) console.error('You attempted to bind a node to %o, which does not exist on %o, with bindText: %o', bind.key, bind._data, bind.base);                                return val;                            }                            return runThroughFilters(bind._data.get(bind.key), bind.filters, bind._data.filters);                        }                        return bind;                    }).join('');                    if (!foundEmpty) {                        localComponent = tempDiv.children[0];                        frag.replaceChild(localComponent, tempDiv);                        this.base.local.parentElement.stopChange().replaceChild(frag, this.base.local);                        this.base.local = localComponent;                        _onEvent({                            event: 'replaceNode',                            node: this.base.local,                            parent: this.node,                            map: this.base                        });                    }                }                function setLoop(index, event) {                    switch (event) {                        case 'create':                            this.addPointer(index);                            break;                        case 'delete':                            this.removePointer(index);                            break;                        case 'set':                            this.reapplyPointer(index);                            break;                        default:                            if (event !== 'push') {                                for (var x = 0, len = this._data.getLayer(this.key).length; x < len; x++) {                                    this.reapplyPointer(x);                                }                            }                            break;                    }                    return this;                }                function createloop() {                    this.node.stopChange().innerHTML = "";                    var forData = runThroughForFilters(this._data.get(this.key), this.filters.filters, this._data.filters);                    for (var x = 0, len = forData.length; x < len; x++) {                        this.setLoop(x, 'create');                    }                    return this;                }                function reapplyPointer(index) {                    var childMaps = this.node.children[index].kb_maps,                        childPointers = this.node.children[index].kb_viewmodel.pointers,                        loopid = this.node.children[index].kb_viewmodel.loopid;                    for (var x = 0, keys = Object.keys(childPointers), len = keys.length; x < len; x++) {                        var _maps = childMaps[keys[x]];                        if (_maps !== undefined) {                            for (var i = 0, lenn = _maps.length; i < lenn; i++) {                                _maps[i].reconnect();                            }                        }                    }                    this.node.children[index].kb_viewmodel.x = index;                    this.node.children[index].kb_viewmodel.loopid = loopid.substring(0, (loopid.lastIndexOf('_') + 1)) + index;                    return this;                }                function addPointer(index) {                    var newNode = document.createElement(this.component),                        data = runThroughForFilters(this._data.getLayer(this.key), this.filters.filters, this._data.filters, index)[index];                    for (var x = 0, keys = Object.keys(data, 'all'), len = keys.length; x < len; x++) {                        if (!newNode.k_post) newNode.k_post = {};                        newNode.k_post[keys[x]] = data;                        newNode.k_post.x = index;                        newNode.k_post.loopid = this.component + "_" + index;                    }                    if (index >= this.node.children.length) {                        this.node.stopChange().appendChild(newNode);                    } else {                        this.node.stopChange().insertBefore(newNode, this.node.children[index]);                    }                    _onEvent({                        event: 'loopitem',                        node: newNode,                        parent: this.node,                        map: this                    });                    return this;                }                function removePointer(index) {                    var childMaps = this.node.children[index].kb_maps,                        childPointers = this.node.children[index].kb_viewmodel.pointers;                    for (var x = 0, keys = Object.keys(childPointers), len = keys.length; x < len; x++) {                        var _maps = childMaps[keys[x]];                        if (!!_maps) {                            for (var i = 0, lenn = _maps.length; i < lenn; i++) {                                _maps[i].unsync();                                _maps[i] = null;                                delete _maps[i];                            }                        }                    }                    this.node.stopChange().removeChild(this.node.children[index]);                    for (var x = 0, len = this.node.children.length; x < len; x++) {                        this.node.children[x].kb_viewmodel.x = x;                        var loopid = this.node.children[x].kb_viewmodel.loopid;                        this.node.children[x].kb_viewmodel.loopid = loopid.substring(0, (loopid.lastIndexOf('_') + 1)) + x;                    }                    return this;                }                function unsync() {                    this.__proto__.bindText = null;                    this._data = null;                    delete this._data;                    this.bindMaps = null;                    delete this.bindMaps;                    this.binds = null;                    delete this.binds;                    return this;                }                Object.defineProperties(bind.prototype, {                    addPointer: setDescriptor(addPointer),                    removePointer: setDescriptor(removePointer),                    reapplyPointer: setDescriptor(reapplyPointer),                    connect: setDescriptor(connect),                    reconnect: setDescriptor(reconnect),                    createloop: setDescriptor(createloop),                    setData: setDescriptor(setData),                    setDom: setDescriptor(setDom),                    setLoop: setDescriptor(setLoop),                    bindMaps: setDescriptor([]),                    unsync: setDescriptor(unsync),                    reset: setDescriptor(reset),                    replaceNode: setDescriptor(replaceNode)                })                return bind;            }            return KonnektMP;        }        return CreateKonnektMP;    }(Createkb))    var CreateKonnektRTF = (function() {        function CreaKonnektRTF() {            var _base = '',                _onChange = function() {},                _hashlisteners = [],                _onEvent = function(e) {                    for (var x = 0, len = _hashlisteners.length; x < len; x++) {                        if (!e._stopPropogation) _hashlisteners[x](e);                    }                    return e._preventDefault;                }            function KonnektRTF(name) {                if (name.length === 0) name = _base;                var e = new eventObject(name);                if (!_onEvent(e)) {                    document.body.innerHTML = "<" + e.hash + "></" + e.hash + ">";                    _onChange(e.hash);                }                return KonnektRTF;            }            function eventObject(hash) {                this.preventDefault = function() {                    this._preventDefault = true;                }                this.stopPropogation = function() {                    this._stopPropogation = true;                }                this.hash = hash;                this.url = window.location.href;            }            KonnektRTF.base = function(v) {                if (v === undefined) return _base;                _base = (typeof v === 'string' ? v : _base);                return KonnektRTF;            }            KonnektRTF.addHashListener = function(func) {                _hashlisteners.push(func);                return KonnektRTF;            }            KonnektRTF.removeHashListener = function(func) {                for (var x = 0, len = _hashlisteners.length; x < len; x++) {                    if (_hashlisteners[x].toString() === func.toString()) {                        _hashlisteners.splice(x, 1);                        break;                    }                }                return KonnektRTF;            }            KonnektRTF.onChange = function(v) {                if (v === undefined) return _onChange;                _onChange = (typeof v === 'function' ? v : _onChange);                return KonnektRTF;            }            KonnektRTF.watch = function(v) {                if (v) {                    window.onhashchange = function() {                        KonnektRTF(window.location.hash.replace('#', ''));                    }                } else {                    window.onhashchange = null;                }                return KonnektRTF;            }            return KonnektRTF;        }        return CreaKonnektRTF;    }());    var CreateKonnekt = (function(CreateData, CreateLoader, kb, CreateMapping, CreateHashRouting) {        function CreateKonnekt(config) {            if (!window.K_Components) window.K_Components = {};            /* main loader for loading files */            var _Loader = CreateLoader().onLoad(onComponentLoad),                /* Our mixed observable data library */                _mixed = CreateData(),                _config = config || {},                _fetchedConfigs = false,                _onConfigsFetched = [],                /* mapping library, for mapping new component: new _mapper(componentNode) */                _mapper = CreateMapping()                .addEventListener('loopitem', buildNode)                .addEventListener('replaceNode', buildNode),                /* routes components based on the current url hash, config.base sets the default route of '/' */                _hashrouter = CreateHashRouting()                .base((_config.base !== undefined ? _config.base : 'default'))                .watch(true)                .onChange(function(name) {                    Konnekt(document.querySelector(name));                }),                /* this is a main model, data sets will be stored here for sharing between components and other libraries through this.store = true attribute */                _model = _mixed({}, "Model"),                /* the current loaded viewmodels */                _viewmodels = {},                /* this will be used later for current loaded cms components */                _cms = {},                /* handles standard message event buses */                _messages = {},                /* handles more specific node scoped event buses */                _scopemessages = {},                /* url query attached to web addres: ?env=dev etc */                _query = getQuery(),                /* important ignore list for when creating a viewmodel, these attributes are not used for binding */                _ignoreList = ['id', 'filters', 'class', 'sessionStorage', 'localStorage', 'store', 'component', 'multiple'],                /* used for onload events, when a component has not been loaded from the server a request for load is made and the current script is placed in the waitlist until it has been loaded from the server to continue operation */                _waitList = {},                _baserouter;            /* This method will Create page, Create Viewmodel, attach binds, check children, load files, rinse, repeat */            function Konnekt(node, params, predt, postdt, cb) {                /* name of the component */                var __name = node.tagName.toLowerCase(),                    /* the mapped binds */                    __mappedAttrs,                    /* we can get a list of all possibe events from the HTMLElement prototype */                    __events = Object.keys(HTMLElement.prototype)                    .filter(function(prop) {                        /* we filter for 'on' properties as these are all events */                        return (prop.indexOf('on') === 0);                    }),                    /* Pre -- all about built in data this will be allocated later to seperate file */                    /* Note** we may need to take another look at this as mixed pointers are being double processed */                    pre = passKeys(_config, {}),                    /* post all about post set data and pointers */                    /* Note** we may need to take another look at this as mixed pointers are being double processed */                    post = {};                /* params are extra information passed to the viewmodel constructor, example: componentNode */                if (params === undefined) params = [];                if (predt) passKeys(predt, pre);                Object.defineProperty(pre, 'local', setDescriptor(pre.local || ("local_" + __name + "-" + (Math.floor(Math.random() * Date.now()) + 1)), true, false, true));                Object.defineProperty(pre, 'id', setDescriptor(pre.id || ("id_" + __name + "-" + (Math.floor(Math.random() * Date.now()) + 1)), true, false, true));                /* base core filters usable in all components */                Object.defineProperty(pre, 'filters', setDescriptor(pre.filters || {}, false, false, true));                if (typeof pre.onFinish !== 'function') pre.onFinish = function() {};                Object.defineProperty(pre, 'onGlobalFinish', setDescriptor(pre.onFinish, true, false, true));                /* add listen method */                pre.listen = listen;                Object.defineProperty(pre, 'listen', setDescriptor(pre.listen, true, false, true));                /* add unlisten method */                pre.unlisten = unlisten;                Object.defineProperty(pre, 'unlisten', setDescriptor(pre.unlisten, true, false, true));                /* add alert method */                pre.alert = alert;                Object.defineProperty(pre, 'alert', setDescriptor(pre.alert, true, false, true));                /* whether to attempt to store data in sessionStorage */                Object.defineProperty(pre, 'sessionStorage', setDescriptor((false), true, false, true));                /* whether to attempt to store data in localStorage */                Object.defineProperty(pre, 'localStorage', setDescriptor((false), true, false, true));                /* whether to attempt to store data in the model */                Object.defineProperty(pre, 'store', setDescriptor((false), true, false, true));                /* if this component can have children components of the same type, to prevent recursion */                Object.defineProperty(pre, 'multiple', setDescriptor((false), true, false, true));                if (postdt) passKeys(postdt, post);                /* if the component contained any innerHTML this gets placed into a post bindable */                post.innerHTML = Array.prototype.slice.call(node.childNodes);                for (var x = 0, len = node.attributes.length; x < len; x++) {                    post[node.attributes[x].name] = node.attributes[x].value;                }                /* add all events to post for binding to inner component */                for (var x = 0, len = __events.length; x < len; x++) {                    if (node[__events[x]]) post[__events[x]] = node[__events[x]];                }                /* add any data attached to k_post  property */                if (node.k_post) passKeys(node.k_post, post);                /* The main viewmodel constructor */                function createViewmodel(name, component, params, pre, post) {                    /* creates blank observable data set */                    var obsv = _mixed({}, name);                    /* Attach Pre properties, or pre designed attachments for every Data set */                    for (var x = 0, keys = Object.keys(pre), len = keys.length; x < len; x++) {                        if (_ignoreList.indexOf(keys[x]) !== -1) {                            Object.defineProperty(obsv, keys[x], setDescriptor(pre[keys[x]], (keys[x] !== 'filters')));                        } else {                            if (pre.pointers) {                                if (pre.pointers[keys[x]] === undefined) obsv.set(keys[x], pre[keys[x]]);                            } else {                                obsv.set(keys[x], pre[keys[x]]);                            }                        }                    }                    if (pre.pointers) {                        if (!obsv.pointers) Object.defineProperty(obsv, 'pointers', setDescriptor({}, false, true));                        for (var x = 0, keys = Object.keys(pre.pointers), len = keys.length; x < len; x++) {                            obsv.pointers[keys[x]] = pre.pointers[keys[x]];                            obsv.addPointer(obsv.pointers[keys[x]].point, obsv.pointers[keys[x]].key, keys[x]);                        }                    }                    /* if there are any prototypes on this component they are added to the Data sets prototype */                    for (var x = 0, keys = Object.keys(component.prototype), len = keys.length; x < len; x++) {                        Object.defineProperty(obsv, [keys[x]], setDescriptor(component.prototype[keys[x]], true));                    }                    /* we then apply the component constructor to the data set in order to add the 'this' properties from it and pass in the params */                    component.apply(obsv, params);                    /* Post attachments, overwritables, for data or pointers */                    for (var x = 0, keys = Object.keys(post), len = keys.length; x < len; x++) {                        if (_ignoreList.indexOf(keys[x]) !== -1) {                            Object.defineProperty(obsv, keys[x], setDescriptor(post[keys[x]], (keys[x] !== 'filters')));                        } else {                            if (post.pointers) {                                if (post.pointers[keys[x]] === undefined) obsv.set(keys[x], post[keys[x]]);                            } else {                                obsv.set(keys[x], post[keys[x]]);                            }                        }                    }                    /* post pointers */                    if (post.pointers) {                        if (!obsv.pointers) Object.defineProperty(obsv, 'pointers', setDescriptor({}, false, true));                        for (var x = 0, keys = Object.keys(post.pointers), len = keys.length; x < len; x++) {                            obsv.pointers[keys[x]] = post.pointers[keys[x]];                            obsv.addPointer(obsv.pointers[keys[x]].point, obsv.pointers[keys[x]].key, keys[x]);                        }                    }                    /* map filters as binded to vm */                    for (var x = 0, keys = Object.keys(obsv.filters), len = keys.length; x < len; x++) {                        obsv.filters[keys[x]] = obsv.filters[keys[x]].bind(obsv);                    }                    /* Apply session storage if set, this allows for storing this vm in session storage, only those values that are enumerable */                    if (obsv.sessionStorage) {                        var storage = sessionStorage.getItem((obsv.id || name));                        /* load storage into the data set if it is set */                        if (storage) {                            storage = JSON.parse(storage);                            for (var x = 0, keys = Object.keys(storage), len = keys.length; x < len; x++) {                                obsv.set(keys[x], storage[keys[x]]);                            }                        }                        /* set the storage object with the defaults */                        else {                            sessionStorage.setItem((obsv.id || name), obsv.stringify());                        }                        /* if any data updates then the storage will be updated along with it */                        obsv.addChildDataUpdateListener('*', function() {                            sessionStorage.setItem((obsv.id || name), obsv.stringify());                        });                    }                    /* Apply local storage if set, similiar to session Storage except this persists even after browser is closed */                    if (obsv.localStorage) {                        var storage = localStorage.getItem((obsv.id || name));                        /* load storage into the data set if it is set */                        if (storage) {                            storage = JSON.parse(storage);                            for (var x = 0, keys = Object.keys(storage), len = keys.length; x < len; x++) {                                obsv.set(keys[x], storage[keys[x]]);                            }                        }                        /* set the storage object with the defaults */                        else {                            localStorage.setItem((obsv.id || name), obsv.stringify());                        }                        /* if any data updates then the storage will be updated along with it */                        obsv.addChildDataUpdateListener('*', function() {                            localStorage.setItem((obsv.id || name), obsv.stringify());                        });                    }                    if (obsv.store) {                        /* adds a pointer in model to this viewmodel, look into using id as an id from component: <test id="storeid"></test> */                        _model.set((obsv.id || name), obsv);                    }                    return obsv;                }                function getInnerMapper(name) {                    return new RegExp('(' + _mapper.start() + '>' + name + '(.*?)' + _mapper.end() + ')', 'g');                }                function innerMapperKeys() {                    return new RegExp('(' + _mapper.start() + '>(.*?)' + _mapper.end() + ')', 'g');                }                /* in charge of connecting the viewmodel up to the allocated maps */                function mapTargets(target, mappedAttrs, vm) {                    /* attaches viewmodel to wrapper */                    target.kb_viewmodel = vm;                    /* map nodes with their bindings */                    var maps = mappedAttrs.maps = mappedAttrs.map(mappedAttrs.wrapper);                    mappedAttrs.wrapper.kb_maps = maps;                    /* loops through maps: {key:[map,map],key2:[map,map]} */                    Object.keys(maps).forEach(function(key) {                        maps[key].forEach(function(map) {                            switch (map.type) {                                case 'for':                                    /* connects viewmodel and then loop creates components for converting and deletes original map*/                                    map.connect(vm).createloop();                                    break;                                case 'component':                                    /* connects viewmodel updates value and then deletes map as it won't be used again */                                    map.connect(vm).unsync();                                    break;                                case 'node':                                    map.connect(vm).replaceNode();                                    break;                                default:                                    /* standard data connection and value set */                                    map.connect(vm);                                    break;                            }                        })                    });                    mappedAttrs.wrapper.kb_viewmodel.onFinish.call(mappedAttrs.wrapper.kb_viewmodel, mappedAttrs.wrapper);                    if (mappedAttrs.wrapper.kb_viewmodel.onGlobalFinish) {                        mappedAttrs.wrapper.kb_viewmodel.onGlobalFinish.call(mappedAttrs.wrapper.kb_viewmodel, mappedAttrs.wrapper);                    }                    if (mappedAttrs.wrapper.kb_viewmodel.onNodeFinish) {                        mappedAttrs.wrapper.kb_viewmodel.onNodeFinish.call(mappedAttrs.wrapper.kb_viewmodel, mappedAttrs.wrapper);                    }                }                function getInnerComponents(node) {                    var nodes = node.querySelectorAll('*');                    for (var x = 0, len = nodes.length; x < len; x++) {                        if (nodes[x] instanceof HTMLUnknownElement) {                            Konnekt(nodes[x]);                        }                    }                }                function init(name, node) {                    /* Create node template and map the inner nodes of the template */                    __mappedAttrs = new _mapper(node, true);                    /* do a replace for simple initial replacements inside binds */                    __mappedAttrs.wrapper.innerHTML = __mappedAttrs.template;                    __mappedAttrs.wrapper.kb_mapper = __mappedAttrs.wrapper;                    /* define component tree for multiples later */                    Object.defineProperty(__mappedAttrs.wrapper, '__kbcomponenttree', setDescriptor(node.kb_mapper ? node.kb_mapper.__kbcomponenttree.slice() : []));                    /* replace original node with new templated node */                    node.parentElement.stopChange().replaceChild(__mappedAttrs.fragment, node);                    /* add new nodes to params for passing to viewmodels */                    params.unshift(__mappedAttrs.wrapper);                    /* map targets connects the viewmodel data to the dom and vice versa */                    mapTargets(__mappedAttrs.wrapper, __mappedAttrs, createViewmodel(name, _viewmodels[name], params, pre, post));                    /* check for multiples */                    if (__mappedAttrs.wrapper.__kbcomponenttree.indexOf(name) === -1 || __mappedAttrs.wrapper.kb_viewmodel.multiple) {                        /* add to component tree and search for inner unkown components */                        __mappedAttrs.wrapper.__kbcomponenttree.push(name);                        __mappedAttrs.wrapper.className += (" " + __mappedAttrs.wrapper.kb_viewmodel.local);                        __mappedAttrs.wrapper.className += (" " + __mappedAttrs.wrapper.kb_viewmodel.id);                        __mappedAttrs.wrapper.className += (!!__mappedAttrs.wrapper.kb_viewmodel.loopid ? " " + __mappedAttrs.wrapper.kb_viewmodel.loopid : "");                        /* watch for changes to alert any scope messages */                        __mappedAttrs.wrapper.kb_viewmodel.subscribeDeep('*', scopesubscription).callAllSubscribers();                        __mappedAttrs.wrapper.kb_viewmodel.kbnode = __mappedAttrs.wrapper;                        /* stop any html updates */                        __mappedAttrs.wrapper.addChildAttrListener('html', function(e) {                            if (!e.stopChange) {                                /* check if its a new component being appended or check if its a single bind */                                if (['appendChild', 'insertSibling', 'insertBefore', 'insertAfter'].indexOf(e.attr) !== -1 && (e.arguments[0] instanceof HTMLUnknownElement || e.arguments[0] instanceof HTMLScriptElement)) {                                    return true;                                } else if (['innerHTML', 'textContent'].indexOf(e.attr) !== -1 && e.target.__kbhtmllistener) {                                    return true;                                }                                e.preventDefault();                                e.stopPropagation();                            }                        });                        __mappedAttrs.wrapper.addChildAttrUpdateListener('html', function(e) {                            if (['appendChild', 'insertSibling', 'insertBefore', 'insertAfter'].indexOf(e.attr) !== -1 && e.arguments[0] instanceof HTMLUnknownElement) {                                Konnekt(e.arguments[0]);                            }                        });                        getInnerComponents(__mappedAttrs.wrapper);                    } else {                        console.error("Warning!! You are attempting to make a recursive component %o, recursive components can lead to memory stack overflows unless properly handled, Please check your components html for use of this component, if You want this to be a recursive component please set `this.multiple = true;`", name);                        console.error("Recursive Component %o on %o", __mappedAttrs.wrapper, __mappedAttrs.wrapper.parentElement);                    }                }                if (!Konnekt.isRegistered(__name) && !node.kb_isLoading) {                    Konnekt.loadWaitList(__name, function(n, c) {                        init(__name, node);                    });                    if (!Konnekt.loadWaitList(__name).loading) {                        Konnekt.loadWaitList(__name).loading = true;                        _Loader(__name);                    }                } else {                    if (Konnekt.isRegistered(__name)) init(__name, node);                }            }            function scopesubscription(e) {                var local = this.__kbref.local,                    id = this.__kbref.id,                    loopid = this.__kbref.loopid,                    key = this.__kbscopeString + (this.__kbscopeString.length !== 0 ? '.' : '') + e.key;                if (_scopemessages[local]) {                    if (_scopemessages[local][key]) {                        for (var x = 0, len = _scopemessages[local][key].length; x < len; x++) {                            _scopemessages[local][key][x](e);                        }                    }                }                if (_scopemessages[id]) {                    if (_scopemessages[id][key]) {                        for (var x = 0, len = _scopemessages[id][key].length; x < len; x++) {                            _scopemessages[id][key][x](e);                        }                    }                }                if (_scopemessages[loopid]) {                    if (_scopemessages[loopid][key]) {                        for (var x = 0, len = _scopemessages[loopid][key].length; x < len; x++) {                            _scopemessages[loopid][key][x](e);                        }                    }                }            }            function buildNode(e) {                var name = e.node.tagName.toLowerCase();                if (!Konnekt.isRegistered(name) && !e.node.kb_isLoading) {                    e.node.kb_isLoading = true;                    Konnekt.loadWaitList(name, function(n, c) {                        if (e.event === 'replaceNode') {                            Konnekt(e.node, [], {                                onNodeFinish: function(node) {                                    e.map.local = node;                                }                            });                        } else {                            Konnekt(e.node);                        }                    });                    if (!Konnekt.loadWaitList(name).loading) {                        Konnekt.loadWaitList(name).loading = true;                        _Loader(name);                    }                } else {                    if (Konnekt.isRegistered(name)) {                        if (e.event === 'replaceNode') {                            Konnekt(e.node, [], {                                onNodeFinish: function(node) {                                    e.map.local = node;                                }                            });                        } else {                            Konnekt(e.node);                        }                    }                }            }            function passKeys(obj, obj2) {                var keys = Object.keys(obj);                if (!obj2.pointers) Object.defineProperty(obj2, 'pointers', {                    value: {},                    writable: true,                    enumerable: false,                    configurable: true                });                for (var x = 0, len = keys.length; x < len; x++) {                    if (_mixed.prototype.isObservable(obj, keys[x])) {                        obj2.pointers[keys[x]] = {                            key: obj.__kbscopeString.split('.').pop(),                            point: obj.__kbImmediateParent                        };                    } else if (_mixed.prototype.isMixed(obj[keys[x]])) {                        obj2.pointers[keys[x]] = {                            key: obj[keys[x]].__kbscopeString.split('.').pop(),                            point: obj[keys[x]].__kbImmediateParent                        };                    } else if (_mixed.prototype.isObject(obj[keys[x]]) && obj[keys[x]].pointer) {                        obj2.pointers[keys[x]] = {                            filters: obj[keys[x]].filters,                            key: obj[keys[x]].key,                            point: obj[keys[x]].pointer                        };                    } else {                        if (_mixed.prototype.isObject(obj[keys[x]])) {                            if (obj2[keys[x]] === undefined) obj2[keys[x]] = {};                            for (var i = 0, keysI = Object.keys(obj[keys[x]]), lenI = keysI.length; i < len; i++) {                                obj2[keys[x]][keysI[i]] = obj[keys[x]][keysI[i]];                            }                        } else if (_mixed.prototype.isArray(obj[keys[x]])) {                            for (var i = 0, lenI = obj[keys[x]].length; i < len; i++) {                                obj2[keys[x]][i] = obj[keys[x]][i];                            }                        } else {                            obj2[keys[x]] = obj[keys[x]];                        }                    }                }                return obj2;            }            function setDescriptor(value, writable, redefinable, enumerable) {                return {                    value: value,                    writable: !!writable,                    enumerable: !!enumerable,                    configurable: !!redefinable                }            }            function getQuery() {                return window.location.search.replace('?', '')                    .split('&')                    .filter(function(v) {                        return (v.length !== 0);                    })                    .reduce(function(o, v) {                        o[v.split('=')[0]] = v.split('=')[1];                        return o;                    }, {});            }            function onComponentLoad(name, component) {                var template = "<style>" + unescape(component.prototype.k_css) + "</style>" + unescape(component.prototype.k_html);                Konnekt.register(name, component, template, component.prototype.cms);                /*_mapper.getUnkowns(template).forEach(function(u){                  _Loader(u);                });*/                if (_fetchedConfigs) {                    Konnekt.loadWaitList(name).forEach(function(onload) {                        onload(name, component);                    });                    Konnekt.loadWaitList(name, 'clear');                } else {                    _onConfigsFetched.push(function() {                        Konnekt.loadWaitList(name).forEach(function(onload) {                            onload(name, component);                        });                        Konnekt.loadWaitList(name, 'clear');                    });                }            }            function sub(e) {                var listeners = _scopemessages[this.query][this.key];                for (var x = 0, len = listeners.length; x < len; x++) {                    listeners[x](e);                }            }            function unlisten(query, key, func) {                /* standard message listener */                if (arguments.length === 2) {                    func = key.bind(this);                    key = query;                    if (_messages[key]) {                        for (var x = 0, len = _messages[key].length; x < len; x++) {                            if (_messages[key][x].toString() === func.toString()) {                                _messages[key].splice(x, 1);                            }                        }                    } else {                        console.error('no listeners exists by key %o', key);                    }                } else {                    func = func.bind(this);                    if (_scopemessages[query] && _scopemessages[query][key]) {                        for (var x = 0, len = _scopemessages[query][key].length; x < len; x++) {                            if (_scopemessages[query][key].toString() === func.toString()) {                                _scopemessages[query][key].splice(x, 1);                            }                        }                    }                }                return this;            }            /* messaging commands */            function listen(query, key, func) {                /* standard message listener */                if (arguments.length === 2) {                    func = key.bind(this);                    key = query;                    if (!_messages[key]) _messages[key] = [];                    _messages[key].push(func);                } else {                    func = func.bind(this);                    if (!_scopemessages[query]) _scopemessages[query] = {};                    if (!_scopemessages[query][key]) _scopemessages[query][key] = [];                    _scopemessages[query][key].push(func);                    /* if this happens to be a parent component we immediately retrieve the value, if not then callAllSubscribers will fire initial */                    if (document.querySelector('.' + query)) {                        var scopeMessages = _scopemessages[query][key],                            data = document.querySelector('.' + query).kb_mapper.kb_viewmodel,                            local = data.getLayer(key),                            localKey = key.split('.').pop(),                            val = local[localKey];                        scopeMessages[(scopeMessages.length - 1)]({                            key: localKey,                            value: val,                            oldValue: val,                            local: local,                            kbref: data,                            onChange: false,                            initial: true                        });                    }                }                return this;            }            function alert(key, e) {                if (_messages[key]) {                    for (var x = 0, len = _messages[key].length; x < len; x++) {                        _messages[key][x](e);                    }                }                return this;            }            /* environment detection */            Konnekt.detectDevice = function() {                var mobile = /(mobi|ipod|phone|blackberry|opera mini|fennec|minimo|symbian|psp|nintendo ds|archos|skyfire|puffin|blazer|bolt|gobrowser|iris|maemo|semc|teashark|uzard|[^a-z]rim[^a-z]|sonyericsson|nokia|[^a-z]mib[^a-z])/,                    tablet = /(ipad|tablet|(android(?!.*mobile))|(windows(?!.*phone)(.*touch))|kindle|playbook|silk|(puffin(?!.*(IP|AP|WP))))/;                if (navigator.userAgent.toLowerCase().match(mobile)) return 'mobile';                if (navigator.userAgent.toLowerCase().match(tablet)) return 'tablet';                return 'desktop';            }            Konnekt.detectBrowser = function() {                // Opera 8.0+                var isOpera = ((!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0);                // Firefox 1.0+                var isFirefox = (typeof InstallTrigger !== 'undefined');                // Safari 3.0+ "[object HTMLElementConstructor]"                 var isSafari = (/constructor/i.test(window.HTMLElement) || (function(p) {                    return p.toString() === "[object SafariRemoteNotification]";                })(!window['safari'] || safari.pushNotification));                // Internet Explorer 6-11                var isIE = /*@cc_on!@*/ false || !!document.documentMode;                // Edge 20+                var isEdge = !isIE && !!window.StyleMedia;                // Chrome 1+                var isChrome = !!window.chrome && !!window.chrome.webstore;                return isOpera ? 'opera' :                    isFirefox ? 'firefox' :                    isSafari ? 'safari' :                    isChrome ? 'chrome' :                    isIE ? 'ie' :                    isEdge ? 'edge' :                    "unknown";            }            Konnekt.detectOrientation = function() {                if (screen.width > screen.height) {                    return 'landscape';                } else if (screen.height > screen.width) {                    return 'portrait';                } else {                    return 'square';                }            }            Konnekt.detectScreenOrientation = function() {                if (window.innerWidth > window.innerHeight) {                    return 'landscape-size';                } else if (window.innerHeight > window.innerWidth) {                    return 'portrait-size';                } else {                    return 'square-size';                }            }            Konnekt.detectScreenSize = function() {                if ((this.detectOrientation() === 'landscape' ? window.innerWidth : window.innerHeight) < 1280) {                    if ((this.detectOrientation() === 'landscape' ? window.innerWidth : window.innerHeight) < 750) {                        return 'mobile-size';                    }                    return 'tablet-size';                } else {                    return 'desktop-size';                }            }            Konnekt.config = function(v) {                function recSet(from, to) {                    for (var x = 0, keys = Object.keys(from), len = keys.length; x < len; x++) {                        if (typeof from[keys[x]] === 'object') {                            if (to[keys[x]] === undefined) to[keys[x]] = {};                            recSet(from[keys[x]], to[keys[x]]);                        } else if (to[keys[x]] !== 'object') {                            to[keys[x]] = from[keys[x]];                        }                    }                }                recSet(v, _config);                return Konnekt;            };            function detectKeyboard() {                /* detect if the current window size is smaller than 60% of the original device size */                return (window.innerHeight < screen.height - (screen.height * 0.40));            }            function setBaseClasses() {                if (!document.querySelector('meta[name="viewport"]')) {                    var meta = document.createElement('meta');                    meta.name = 'viewport';                    meta.content = 'width=device-width, initial-scale=1.0';                    document.head.stopChange().appendChild(meta);                }                if (!Konnekt.device) Konnekt.device = {};                Konnekt.device.type = Konnekt.detectDevice();                Konnekt.device.orientation = Konnekt.detectOrientation();                Konnekt.device.browser = Konnekt.detectBrowser();                Konnekt.device.screenSize = Konnekt.detectScreenSize();                Konnekt.device.orientationSize = Konnekt.detectScreenOrientation();                Konnekt.device.keyboard = (Konnekt.device.type !== 'desktop' ? (detectKeyboard()) : false);                document.body.className = Konnekt.device.type +                    " " + Konnekt.device.orientation +                    (Konnekt.device.keyboard ? ' keyboard' : '') +                    " " + Konnekt.device.browser +                    " " + Konnekt.device.screenSize +                    " " + Konnekt.device.orientationSize;            }            window.addEventListener('resize', setBaseClasses);            if (document.body) {                setBaseClasses();            } else {                document.addEventListener("DOMContentLoaded", function() {                    setBaseClasses();                })            }            /* Registers name to a component */            Konnekt.register = function(name, vm, template, cms) {                _mapper.register(name, template);                _viewmodels[name] = vm;                if (cms) _cms[name] = cms;                return Konnekt;            }            Konnekt.isRegistered = function(name) {                return (_viewmodels[name] !== undefined && _mapper.isRegistered(name));            }            Konnekt.registered = function() {                return Object.keys(_viewmodels);            }            /* register for a component to load and be registered */            Konnekt.loadWaitList = function(name, v) {                if (typeof v === 'undefined' && name) return _waitList[name];                if (name) {                    if (_waitList[name] === undefined || v === 'clear') {                        var loaded = (_waitList[name] === undefined ? false : !!_waitList[name].loading);                        _waitList[name] = [];                        _waitList[name].loading = loaded;                    }                    if (typeof v === 'function') _waitList[name].push(v);                }                return Konnekt;            }            Konnekt.localRouting = function(isRouting) {                if (isRouting) {                    _baserouter = Node.prototype.appendChild;                    Node.prototype.appendChild = function(node) {                        if (node.nodeName.toLowerCase() === 'script') {                            node.src = node.src.substring(0, (node.src.indexOf('?') !== -1 ? node.src.indexOf('?') : node.src.length));                            var match = node.src.match(/(.*?component\/)/);                            if (match) {                                if (!_query.env) _query.env = 'prod';                                if (_query.env === 'dev') _query.env = 'qa';                                var name = node.src.replace(match[0], '').replace(/[\/\s]/g, '');                                node.src = (_config.prefix !== undefined ? _config.prefix : '') + '/components/' + name + '/build/' + _query.env + '/' + name + (!_query.debug || _query.env === 'prod' ? '.min' : '') + '.js';                                arguments[0] = node;                            }                        }                        return _baserouter.apply(this, arguments);                    }                } else {                    if (_baserouter) {                        Node.prototype.appendChild = _baserouter;                        _baserouter = null;                    }                }                return Konnekt;            }            Konnekt.hashRouting = function(isHashed) {                if (isHashed) {                    if (!document.body) {                        document.addEventListener('DOMContentLoaded', function() {                            if (!_fetchedConfigs) {                                _onConfigsFetched.push(function() {                                    _hashrouter(window.location.hash.replace('#', ''));                                });                            } else {                                _hashrouter(window.location.hash.replace('#', ''));                            }                        });                    } else {                        if (!_fetchedConfigs) {                            _onConfigsFetched.push(function() {                                _hashrouter(window.location.hash.replace('#', ''));                            });                        } else {                            _hashrouter(window.location.hash.replace('#', ''));                        }                    }                }                return this;            }            Konnekt.addHashRouter = function(func) {                _hashrouter.addHashListener(func);                return Konnekt;            }            Konnekt.removeHashRouter = function(func) {                _hashrouter.removeHashListener(func);                return Konnekt;            }            if (!_mixed.prototype._parse) _mixed.prototype._parse = _mixed.prototype.parse;            _mixed.prototype.parse = function() {                if (this.__kbref.kbnode) {                    var maps = this.__kbref.kbnode.kb_mapper.kb_maps,                        parsed = this._parse.apply(this, arguments);                    this.unsubscribeDeep('*', scopesubscription);                    this.subscribeDeep('*', scopesubscription).callAllSubscribers();                    Object.keys(maps).forEach(function(key) {                        maps[key].forEach(function(map) {                            map.reset();                        });                    });                } else {                    return this._parse.apply(this, arguments);                }            }            /* bring in Konnekt config */            function createScript(url, cb) {                var sc = document.createElement('script');                sc.src = url;                sc.onerror = function() {                    cb(null, true);                }                sc.onload = function() {                    cb(_config);                }                document.head.stopChange().appendChild(sc);            }            function checkNode_config(cb) {                createScript((_config.prefix !== undefined ? _config.prefix : '') + '/node_modules/konnekt/config/config.js', cb);            }            function checkBower_config(cb) {                createScript((_config.prefix !== undefined ? _config.prefix : '') + '/bower_components/konnekt/config/config.js', cb);            }            function checkLocal_config(cb) {                createScript((_config.prefix !== undefined ? _config.prefix : '') + '/config/config.js', cb);            }            function callWaitConfigMethods() {                for (var x = 0, len = _onConfigsFetched.length; x < len; x++) {                    _onConfigsFetched[x]();                }            }            (function() {                checkNode_config(function(config, err) {                    if (err) {                        checkBower_config(function(config, err) {                            if (err) console.error("the Konnekt local config was not found, this issue happens when You do not have Konnekt isntalled via th standard node_modules or bower_components module directories");                            checkLocal_config(function(cofig, err) {                                /* this is the finish of the chain */                                _fetchedConfigs = true;                                callWaitConfigMethods();                            });                        });                    } else {                        checkLocal_config(function(cofig, err) {                            /* this is the finish of the chain */                            _fetchedConfigs = true;                            callWaitConfigMethods();                        });                    }                })            }())            window.Konnekt = Konnekt;            return Konnekt;        }        return CreateKonnekt;    }(CreateKonnektDT, CreateKonnektL, Createkb, CreateKonnektMP, CreateKonnektRTF));    if ((typeof window !== 'undefined') && (typeof window.define !== 'undefined') && (typeof window.require !== 'undefined')) {        define([], function() {            return CreateKonnekt;        });    } else if ((typeof module !== 'undefined')) {        module.exports = CreateKonnekt;    }    return CreateKonnekt;}())